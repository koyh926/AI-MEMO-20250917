# Story 4.8: 토큰 사용량 모니터링

## Status

Draft

## Story

**As a** 시스템 관리자,
**I want** AI API 토큰 사용량을 실시간으로 모니터링하고 관리할 수 있는 시스템,
**so that** 비용을 효율적으로 관리하고 서비스 중단을 방지할 수 있다.

## Acceptance Criteria

1. 실시간 토큰 사용량 대시보드가 제공되어야 한다
2. 일별, 주별, 월별 토큰 사용량 통계를 확인할 수 있어야 한다
3. 사용자별 토큰 사용량을 추적할 수 있어야 한다
4. 토큰 사용량이 임계치에 도달하면 알림이 전송되어야 한다
5. 토큰 사용량 예측 및 트렌드 분석이 제공되어야 한다
6. API 호출별 토큰 소비량이 상세히 기록되어야 한다
7. 비용 최적화를 위한 권장사항이 제공되어야 한다
8. 토큰 할당량 관리 기능이 있어야 한다
9. 사용량 리포트를 CSV/PDF로 내보낼 수 있어야 한다
10. 사용량 기반 사용자 제한 기능이 있어야 한다

## Tasks / Subtasks

- [ ] 토큰 사용량 추적 시스템 (AC: 1, 2, 3, 6)
  - [ ] 토큰 사용량 데이터베이스 스키마
  - [ ] 실시간 사용량 수집 미들웨어
  - [ ] 사용량 집계 및 통계 생성
  - [ ] 사용자별 사용량 추적
- [ ] 모니터링 대시보드 구현 (AC: 1, 2, 5)
  - [ ] 실시간 사용량 대시보드 UI
  - [ ] 차트 및 그래프 컴포넌트
  - [ ] 트렌드 분석 시각화
  - [ ] 예측 알고리즘 구현
- [ ] 알림 및 제한 시스템 (AC: 4, 8, 10)
  - [ ] 임계치 설정 및 관리
  - [ ] 알림 전송 시스템
  - [ ] 사용자 제한 로직
  - [ ] 할당량 관리 인터페이스
- [ ] 리포팅 및 최적화 (AC: 7, 9)
  - [ ] 사용량 리포트 생성
  - [ ] 비용 최적화 분석
  - [ ] 데이터 내보내기 기능
  - [ ] 권장사항 엔진

## Dev Notes

### 데이터베이스 스키마

**토큰 사용량 추적 테이블:**

```sql
CREATE TABLE token_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  session_id VARCHAR(100),
  api_endpoint VARCHAR(100) NOT NULL,
  operation_type VARCHAR(50) NOT NULL, -- 'summary' | 'tags' | 'chat'
  note_id UUID REFERENCES notes(id),
  input_tokens INTEGER NOT NULL DEFAULT 0,
  output_tokens INTEGER NOT NULL DEFAULT 0,
  total_tokens INTEGER NOT NULL DEFAULT 0,
  model_name VARCHAR(50) NOT NULL,
  cost_usd DECIMAL(10, 6),
  latency_ms INTEGER,
  success BOOLEAN NOT NULL DEFAULT true,
  error_type VARCHAR(50),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 인덱스
CREATE INDEX idx_token_usage_user_date ON token_usage(user_id, created_at);
CREATE INDEX idx_token_usage_date ON token_usage(created_at);
CREATE INDEX idx_token_usage_operation ON token_usage(operation_type, created_at);
CREATE INDEX idx_token_usage_model ON token_usage(model_name, created_at);

-- 일별 집계 테이블
CREATE TABLE token_usage_daily (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  date DATE NOT NULL,
  user_id UUID REFERENCES auth.users(id),
  operation_type VARCHAR(50),
  model_name VARCHAR(50),
  total_requests INTEGER NOT NULL DEFAULT 0,
  total_input_tokens BIGINT NOT NULL DEFAULT 0,
  total_output_tokens BIGINT NOT NULL DEFAULT 0,
  total_tokens BIGINT NOT NULL DEFAULT 0,
  total_cost_usd DECIMAL(12, 6) NOT NULL DEFAULT 0,
  avg_latency_ms DECIMAL(8, 2),
  success_rate DECIMAL(5, 4),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(date, user_id, operation_type, model_name)
);

-- 사용량 한도 설정 테이블
CREATE TABLE token_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  limit_type VARCHAR(20) NOT NULL, -- 'daily' | 'monthly' | 'total'
  operation_type VARCHAR(50), -- NULL이면 전체
  token_limit BIGINT NOT NULL,
  cost_limit_usd DECIMAL(10, 2),
  current_usage BIGINT NOT NULL DEFAULT 0,
  current_cost_usd DECIMAL(10, 2) NOT NULL DEFAULT 0,
  reset_date DATE,
  active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### 토큰 사용량 추적 미들웨어

**TokenTracker 클래스:**

```typescript
// lib/ai/token-tracker.ts
export interface TokenUsageData {
  userId?: string
  sessionId: string
  apiEndpoint: string
  operationType: 'summary' | 'tags' | 'chat'
  noteId?: string
  inputTokens: number
  outputTokens: number
  totalTokens: number
  modelName: string
  costUsd?: number
  latencyMs: number
  success: boolean
  errorType?: string
}

export class TokenTracker {
  private static instance: TokenTracker
  private usageQueue: TokenUsageData[] = []
  private isFlushingQueue = false

  static getInstance(): TokenTracker {
    if (!TokenTracker.instance) {
      TokenTracker.instance = new TokenTracker()
    }
    return TokenTracker.instance
  }

  constructor() {
    this.startPeriodicFlush()
  }

  async trackUsage(data: TokenUsageData): Promise<void> {
    // 비용 계산
    data.costUsd = this.calculateCost(data.modelName, data.inputTokens, data.outputTokens)
    
    // 큐에 추가
    this.usageQueue.push(data)

    // 큐가 100개 이상이면 즉시 플러시
    if (this.usageQueue.length >= 100) {
      await this.flushQueue()
    }
  }

  private calculateCost(model: string, inputTokens: number, outputTokens: number): number {
    // Gemini 2.0 Flash 가격 (예시)
    const pricing = {
      'gemini-2.0-flash-001': {
        input: 0.000075, // $0.075 per 1K tokens
        output: 0.0003   // $0.30 per 1K tokens
      }
    }

    const modelPricing = pricing[model as keyof typeof pricing] || pricing['gemini-2.0-flash-001']
    
    const inputCost = (inputTokens / 1000) * modelPricing.input
    const outputCost = (outputTokens / 1000) * modelPricing.output
    
    return inputCost + outputCost
  }

  private async flushQueue(): Promise<void> {
    if (this.isFlushingQueue || this.usageQueue.length === 0) {
      return
    }

    this.isFlushingQueue = true
    const usageToFlush = [...this.usageQueue]
    this.usageQueue = []

    try {
      await fetch('/api/admin/token-usage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ usage: usageToFlush })
      })
    } catch (error) {
      // 실패한 데이터는 다시 큐에 추가
      this.usageQueue.unshift(...usageToFlush)
      console.error('토큰 사용량 기록 실패:', error)
    } finally {
      this.isFlushingQueue = false
    }
  }

  private startPeriodicFlush(): void {
    // 10초마다 큐 플러시
    setInterval(() => {
      this.flushQueue()
    }, 10000)

    // 페이지 언로드 시 남은 데이터 전송
    if (typeof window !== 'undefined') {
      window.addEventListener('beforeunload', () => {
        if (this.usageQueue.length > 0) {
          navigator.sendBeacon('/api/admin/token-usage', JSON.stringify({
            usage: this.usageQueue
          }))
        }
      })
    }
  }

  // 현재 사용자의 오늘 사용량 조회
  async getTodayUsage(userId: string): Promise<{
    totalTokens: number
    totalCost: number
    requestCount: number
  }> {
    try {
      const response = await fetch(`/api/admin/token-usage/today?userId=${userId}`)
      return await response.json()
    } catch (error) {
      console.error('오늘 사용량 조회 실패:', error)
      return { totalTokens: 0, totalCost: 0, requestCount: 0 }
    }
  }
}
```

### 모니터링 대시보드

**TokenUsageDashboard 컴포넌트:**

```typescript
// components/admin/token-usage-dashboard.tsx
interface UsageStats {
  totalTokensToday: number
  totalCostToday: number
  totalRequestsToday: number
  topUsers: Array<{
    userId: string
    userName: string
    totalTokens: number
    totalCost: number
  }>
  hourlyUsage: Array<{
    hour: number
    tokens: number
    cost: number
    requests: number
  }>
  operationBreakdown: Array<{
    operation: string
    tokens: number
    cost: number
    percentage: number
  }>
}

export function TokenUsageDashboard() {
  const [stats, setStats] = useState<UsageStats | null>(null)
  const [dateRange, setDateRange] = useState({
    start: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // 7일 전
    end: new Date()
  })
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    loadStats()
    
    // 5분마다 데이터 갱신
    const interval = setInterval(loadStats, 5 * 60 * 1000)
    return () => clearInterval(interval)
  }, [dateRange])

  const loadStats = async () => {
    setLoading(true)
    try {
      const response = await fetch(`/api/admin/token-usage/stats?start=${dateRange.start.toISOString()}&end=${dateRange.end.toISOString()}`)
      const data = await response.json()
      setStats(data)
    } catch (error) {
      console.error('통계 로드 실패:', error)
    } finally {
      setLoading(false)
    }
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    )
  }

  if (!stats) {
    return (
      <div className="text-center text-red-600">
        데이터를 불러올 수 없습니다.
      </div>
    )
  }

  return (
    <div className="token-usage-dashboard space-y-6">
      {/* 오늘의 사용량 요약 */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium text-gray-600">
              오늘 토큰 사용량
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {stats.totalTokensToday.toLocaleString()}
            </div>
            <p className="text-xs text-gray-500">
              {stats.totalRequestsToday}회 요청
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium text-gray-600">
              오늘 비용
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${stats.totalCostToday.toFixed(4)}
            </div>
            <p className="text-xs text-gray-500">
              평균 ${(stats.totalCostToday / Math.max(stats.totalRequestsToday, 1)).toFixed(6)}/요청
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium text-gray-600">
              월 예상 비용
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${(stats.totalCostToday * 30).toFixed(2)}
            </div>
            <p className="text-xs text-gray-500">
              현재 사용량 기준
            </p>
          </CardContent>
        </Card>
      </div>

      {/* 시간별 사용량 차트 */}
      <Card>
        <CardHeader>
          <CardTitle>시간별 사용량</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            {/* 차트 라이브러리 (예: recharts) 사용 */}
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={stats.hourlyUsage}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="hour" />
                <YAxis />
                <Tooltip />
                <Line 
                  type="monotone" 
                  dataKey="tokens" 
                  stroke="#8884d8" 
                  name="토큰"
                />
                <Line 
                  type="monotone" 
                  dataKey="requests" 
                  stroke="#82ca9d" 
                  name="요청 수"
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* 작업별 사용량 분석 */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>작업별 사용량</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-3">
              {stats.operationBreakdown.map((item) => (
                <div key={item.operation} className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <div 
                      className="w-3 h-3 rounded-full"
                      style={{ backgroundColor: getOperationColor(item.operation) }}
                    />
                    <span className="text-sm font-medium">
                      {getOperationLabel(item.operation)}
                    </span>
                  </div>
                  <div className="text-right">
                    <div className="text-sm font-semibold">
                      {item.tokens.toLocaleString()}
                    </div>
                    <div className="text-xs text-gray-500">
                      {item.percentage.toFixed(1)}%
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>상위 사용자</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-3">
              {stats.topUsers.map((user, index) => (
                <div key={user.userId} className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <div className="w-6 h-6 bg-gray-200 rounded-full flex items-center justify-center text-xs font-semibold">
                      {index + 1}
                    </div>
                    <span className="text-sm font-medium">
                      {user.userName || '익명'}
                    </span>
                  </div>
                  <div className="text-right">
                    <div className="text-sm font-semibold">
                      {user.totalTokens.toLocaleString()}
                    </div>
                    <div className="text-xs text-gray-500">
                      ${user.totalCost.toFixed(4)}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      </div>

      {/* 알림 및 제한 설정 */}
      <Card>
        <CardHeader>
          <CardTitle>알림 및 제한 설정</CardTitle>
        </CardHeader>
        <CardContent>
          <TokenLimitSettings />
        </CardContent>
      </Card>
    </div>
  )
}

function getOperationColor(operation: string): string {
  const colors: Record<string, string> = {
    summary: '#8884d8',
    tags: '#82ca9d',
    chat: '#ffc658'
  }
  return colors[operation] || '#666666'
}

function getOperationLabel(operation: string): string {
  const labels: Record<string, string> = {
    summary: '요약 생성',
    tags: '태그 생성',
    chat: '채팅'
  }
  return labels[operation] || operation
}
```

### 알림 시스템

**TokenLimitMonitor 클래스:**

```typescript
// lib/ai/token-limit-monitor.ts
export interface LimitAlert {
  type: 'warning' | 'critical' | 'exceeded'
  userId?: string
  limitType: 'daily' | 'monthly' | 'total'
  operationType?: string
  currentUsage: number
  limit: number
  percentage: number
  timestamp: Date
}

export class TokenLimitMonitor {
  private static instance: TokenLimitMonitor
  private alertQueue: LimitAlert[] = []

  static getInstance(): TokenLimitMonitor {
    if (!TokenLimitMonitor.instance) {
      TokenLimitMonitor.instance = new TokenLimitMonitor()
    }
    return TokenLimitMonitor.instance
  }

  async checkLimits(userId: string, operationType: string, tokensUsed: number): Promise<void> {
    try {
      // 사용자의 모든 제한 조회
      const limits = await this.getUserLimits(userId, operationType)
      
      for (const limit of limits) {
        const newUsage = limit.currentUsage + tokensUsed
        const percentage = (newUsage / limit.tokenLimit) * 100

        // 제한 상태 확인
        let alertType: LimitAlert['type'] | null = null
        
        if (percentage >= 100) {
          alertType = 'exceeded'
        } else if (percentage >= 90) {
          alertType = 'critical'
        } else if (percentage >= 75) {
          alertType = 'warning'
        }

        if (alertType) {
          const alert: LimitAlert = {
            type: alertType,
            userId,
            limitType: limit.limitType as 'daily' | 'monthly' | 'total',
            operationType: limit.operationType || undefined,
            currentUsage: newUsage,
            limit: limit.tokenLimit,
            percentage,
            timestamp: new Date()
          }

          await this.sendAlert(alert)
        }

        // 사용량 업데이트
        await this.updateUsage(limit.id, tokensUsed)
      }
    } catch (error) {
      console.error('제한 확인 실패:', error)
    }
  }

  private async getUserLimits(userId: string, operationType: string) {
    const response = await fetch(`/api/admin/token-limits?userId=${userId}&operationType=${operationType}`)
    return await response.json()
  }

  private async updateUsage(limitId: string, tokensUsed: number) {
    await fetch('/api/admin/token-limits/update-usage', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ limitId, tokensUsed })
    })
  }

  private async sendAlert(alert: LimitAlert): Promise<void> {
    // 중복 알림 방지 (최근 1시간 내 동일 알림 확인)
    const recentAlerts = await this.getRecentAlerts(alert.userId, alert.type, 1)
    if (recentAlerts.length > 0) {
      return
    }

    // 알림 전송
    await Promise.all([
      this.sendEmailAlert(alert),
      this.sendSlackAlert(alert),
      this.logAlert(alert)
    ])
  }

  private async sendEmailAlert(alert: LimitAlert): Promise<void> {
    // 이메일 알림 구현
    console.log('이메일 알림 전송:', alert)
  }

  private async sendSlackAlert(alert: LimitAlert): Promise<void> {
    // 슬랙 알림 구현
    console.log('슬랙 알림 전송:', alert)
  }

  private async logAlert(alert: LimitAlert): Promise<void> {
    await fetch('/api/admin/alerts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(alert)
    })
  }

  private async getRecentAlerts(userId: string | undefined, type: string, hours: number) {
    const since = new Date(Date.now() - hours * 60 * 60 * 1000)
    const response = await fetch(`/api/admin/alerts/recent?userId=${userId}&type=${type}&since=${since.toISOString()}`)
    return await response.json()
  }
}
```

### 비용 최적화 분석

**CostOptimizer 클래스:**

```typescript
// lib/ai/cost-optimizer.ts
export interface OptimizationRecommendation {
  type: 'model_change' | 'prompt_optimization' | 'caching' | 'batching' | 'filtering'
  title: string
  description: string
  estimatedSavings: number
  implementation: string
  priority: 'high' | 'medium' | 'low'
}

export class CostOptimizer {
  async analyzeUsage(userId?: string, days: number = 30): Promise<OptimizationRecommendation[]> {
    const recommendations: OptimizationRecommendation[] = []
    
    // 사용량 데이터 분석
    const usage = await this.getUsageAnalysis(userId, days)
    
    // 1. 모델 변경 권장
    if (usage.averageInputTokens < 1000) {
      recommendations.push({
        type: 'model_change',
        title: '더 저렴한 모델 사용 고려',
        description: '평균 입력 토큰이 1,000개 미만으로, 더 저렴한 모델을 사용할 수 있습니다.',
        estimatedSavings: usage.totalCost * 0.3,
        implementation: 'Gemini Flash 모델로 변경',
        priority: 'high'
      })
    }

    // 2. 프롬프트 최적화
    if (usage.averageInputTokens > 2000) {
      recommendations.push({
        type: 'prompt_optimization',
        title: '프롬프트 길이 최적화',
        description: '프롬프트가 길어 입력 토큰이 많이 소모됩니다.',
        estimatedSavings: usage.totalCost * 0.2,
        implementation: '불필요한 지시사항 제거 및 프롬프트 압축',
        priority: 'medium'
      })
    }

    // 3. 캐싱 권장
    if (usage.duplicateRequestsRate > 0.1) {
      recommendations.push({
        type: 'caching',
        title: '결과 캐싱 구현',
        description: `${(usage.duplicateRequestsRate * 100).toFixed(1)}%의 중복 요청이 발견되었습니다.`,
        estimatedSavings: usage.totalCost * usage.duplicateRequestsRate,
        implementation: 'Redis 기반 결과 캐싱 시스템 구현',
        priority: 'high'
      })
    }

    // 4. 배치 처리
    if (usage.averageRequestsPerHour > 10) {
      recommendations.push({
        type: 'batching',
        title: '배치 처리 도입',
        description: '높은 요청 빈도로 인해 배치 처리가 효율적일 수 있습니다.',
        estimatedSavings: usage.totalCost * 0.15,
        implementation: '여러 요청을 묶어서 처리하는 배치 시스템',
        priority: 'medium'
      })
    }

    // 5. 콘텐츠 필터링
    if (usage.shortContentRate > 0.2) {
      recommendations.push({
        type: 'filtering',
        title: '짧은 콘텐츠 필터링 강화',
        description: `${(usage.shortContentRate * 100).toFixed(1)}%의 요청이 짧은 콘텐츠로 비효율적입니다.`,
        estimatedSavings: usage.totalCost * usage.shortContentRate * 0.5,
        implementation: '최소 길이 제한을 늘리고 사용자 가이드 개선',
        priority: 'low'
      })
    }

    return recommendations.sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 }
      return priorityOrder[b.priority] - priorityOrder[a.priority]
    })
  }

  private async getUsageAnalysis(userId?: string, days: number = 30) {
    const response = await fetch(`/api/admin/token-usage/analysis?userId=${userId}&days=${days}`)
    return await response.json()
  }
}
```

### 사용량 리포트 생성

**ReportGenerator 컴포넌트:**

```typescript
// components/admin/report-generator.tsx
export function ReportGenerator() {
  const [reportType, setReportType] = useState<'daily' | 'weekly' | 'monthly'>('monthly')
  const [dateRange, setDateRange] = useState({
    start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
    end: new Date()
  })
  const [isGenerating, setIsGenerating] = useState(false)

  const generateReport = async (format: 'csv' | 'pdf') => {
    setIsGenerating(true)
    try {
      const response = await fetch('/api/admin/reports/token-usage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: reportType,
          startDate: dateRange.start.toISOString(),
          endDate: dateRange.end.toISOString(),
          format
        })
      })

      if (response.ok) {
        const blob = await response.blob()
        const url = window.URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = `token-usage-report-${reportType}-${format}`
        a.click()
        window.URL.revokeObjectURL(url)
      }
    } catch (error) {
      console.error('리포트 생성 실패:', error)
    } finally {
      setIsGenerating(false)
    }
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>사용량 리포트 생성</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div>
          <label className="text-sm font-medium">리포트 유형</label>
          <select
            value={reportType}
            onChange={(e) => setReportType(e.target.value as any)}
            className="w-full mt-1 p-2 border rounded-md"
          >
            <option value="daily">일별</option>
            <option value="weekly">주별</option>
            <option value="monthly">월별</option>
          </select>
        </div>

        <div>
          <label className="text-sm font-medium">기간</label>
          <div className="flex gap-2 mt-1">
            <input
              type="date"
              value={dateRange.start.toISOString().split('T')[0]}
              onChange={(e) => setDateRange(prev => ({
                ...prev,
                start: new Date(e.target.value)
              }))}
              className="flex-1 p-2 border rounded-md"
            />
            <input
              type="date"
              value={dateRange.end.toISOString().split('T')[0]}
              onChange={(e) => setDateRange(prev => ({
                ...prev,
                end: new Date(e.target.value)
              }))}
              className="flex-1 p-2 border rounded-md"
            />
          </div>
        </div>

        <div className="flex gap-2">
          <button
            onClick={() => generateReport('csv')}
            disabled={isGenerating}
            className="flex-1 bg-blue-500 text-white p-2 rounded-md hover:bg-blue-600 disabled:opacity-50"
          >
            {isGenerating ? <Loader2 className="h-4 w-4 animate-spin mx-auto" /> : 'CSV 다운로드'}
          </button>
          <button
            onClick={() => generateReport('pdf')}
            disabled={isGenerating}
            className="flex-1 bg-green-500 text-white p-2 rounded-md hover:bg-green-600 disabled:opacity-50"
          >
            {isGenerating ? <Loader2 className="h-4 w-4 animate-spin mx-auto" /> : 'PDF 다운로드'}
          </button>
        </div>
      </CardContent>
    </Card>
  )
}
```

## Change Log

| Date       | Version | Description | Author                    |
| ---------- | ------- | ----------- | ------------------------- |
| 2025-09-17 | 1.0     | 스토리 생성 | Scrum Master Bob Claude 4 Sonnet |

## Dev Agent Record

이 섹션은 개발 에이전트가 구현 중에 채워집니다.

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results

QA 에이전트가 완료된 스토리 구현을 검토한 결과입니다.
