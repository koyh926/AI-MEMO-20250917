# Story 4.6: 요약/태그 수동 편집 기능

## Status

Draft

## Story

**As a** 사용자,
**I want** AI가 생성한 요약과 태그를 직접 수정하고 편집할 수 있는 기능,
**so that** AI 결과를 내 의도에 맞게 조정하고 더 정확한 정보로 개선할 수 있다.

## Acceptance Criteria

1. 생성된 요약을 클릭하여 인라인 편집 모드로 전환할 수 있어야 한다
2. 요약 편집 시 텍스트 영역이 자동으로 크기 조정되어야 한다
3. 개별 태그를 클릭하여 편집할 수 있어야 한다
4. 태그를 드래그앤드롭으로 순서를 변경할 수 있어야 한다
5. 새로운 태그를 추가할 수 있어야 한다
6. 불필요한 태그를 삭제할 수 있어야 한다
7. 편집 중 ESC 키로 변경사항을 취소할 수 있어야 한다
8. 편집 완료 시 Enter 키 또는 포커스 아웃으로 저장되어야 한다
9. 편집된 내용이 실시간으로 데이터베이스에 저장되어야 한다
10. 편집 히스토리가 기록되어 이전 버전으로 되돌릴 수 있어야 한다

## Tasks / Subtasks

- [ ] 인라인 편집 컴포넌트 구현 (AC: 1, 2, 7, 8)
  - [ ] 요약 인라인 편집기 컴포넌트
  - [ ] 자동 크기 조정 텍스트 영역
  - [ ] 키보드 이벤트 핸들링 (Enter, ESC)
  - [ ] 포커스 관리 및 저장 로직
- [ ] 태그 편집 시스템 구현 (AC: 3, 4, 5, 6)
  - [ ] 개별 태그 편집 컴포넌트
  - [ ] 드래그앤드롭 정렬 기능
  - [ ] 태그 추가/삭제 UI
  - [ ] 태그 유효성 검증
- [ ] 자동 저장 시스템 (AC: 9)
  - [ ] 디바운싱된 자동 저장
  - [ ] 저장 상태 표시
  - [ ] 네트워크 오류 시 재시도 로직
  - [ ] 오프라인 지원
- [ ] 편집 히스토리 관리 (AC: 10)
  - [ ] 버전 관리 데이터베이스 스키마
  - [ ] 히스토리 추적 및 저장
  - [ ] 버전 복원 기능
  - [ ] 히스토리 UI 컴포넌트

## Dev Notes

### 데이터베이스 스키마 확장

**편집 히스토리 테이블:**

```sql
CREATE TABLE ai_edit_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  note_id UUID NOT NULL REFERENCES notes(id),
  type VARCHAR(20) NOT NULL, -- 'summary' | 'tags'
  previous_value JSONB NOT NULL,
  new_value JSONB NOT NULL,
  edit_type VARCHAR(20) NOT NULL, -- 'manual_edit' | 'ai_generation' | 'regeneration'
  user_id UUID NOT NULL REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 인덱스
CREATE INDEX idx_ai_edit_history_note ON ai_edit_history(note_id, created_at DESC);
CREATE INDEX idx_ai_edit_history_user ON ai_edit_history(user_id, created_at DESC);
```

### 인라인 편집 컴포넌트

**InlineEditor 컴포넌트:**

```typescript
// components/ui/inline-editor.tsx
interface InlineEditorProps {
  value: string
  onSave: (newValue: string) => Promise<void>
  onCancel?: () => void
  placeholder?: string
  multiline?: boolean
  maxLength?: number
  className?: string
}

export function InlineEditor({
  value,
  onSave,
  onCancel,
  placeholder = "클릭하여 편집",
  multiline = false,
  maxLength,
  className
}: InlineEditorProps) {
  const [isEditing, setIsEditing] = useState(false)
  const [editValue, setEditValue] = useState(value)
  const [isSaving, setIsSaving] = useState(false)
  const inputRef = useRef<HTMLInputElement | HTMLTextAreaElement>(null)

  const startEditing = () => {
    setIsEditing(true)
    setEditValue(value)
    // 다음 렌더링 후 포커스
    setTimeout(() => inputRef.current?.focus(), 0)
  }

  const handleSave = async () => {
    if (editValue.trim() === value.trim()) {
      setIsEditing(false)
      return
    }

    setIsSaving(true)
    try {
      await onSave(editValue.trim())
      setIsEditing(false)
    } catch (error) {
      console.error('저장 실패:', error)
      // 에러 처리
    } finally {
      setIsSaving(false)
    }
  }

  const handleCancel = () => {
    setEditValue(value)
    setIsEditing(false)
    onCancel?.()
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !multiline) {
      e.preventDefault()
      handleSave()
    } else if (e.key === 'Enter' && multiline && (e.ctrlKey || e.metaKey)) {
      e.preventDefault()
      handleSave()
    } else if (e.key === 'Escape') {
      e.preventDefault()
      handleCancel()
    }
  }

  if (isEditing) {
    const InputComponent = multiline ? 'textarea' : 'input'
    
    return (
      <div className={`inline-editor ${className}`}>
        <InputComponent
          ref={inputRef as any}
          value={editValue}
          onChange={(e) => setEditValue(e.target.value)}
          onKeyDown={handleKeyDown}
          onBlur={handleSave}
          placeholder={placeholder}
          maxLength={maxLength}
          className="w-full border border-blue-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
          disabled={isSaving}
        />
        {isSaving && (
          <span className="text-xs text-gray-500 ml-2">저장 중...</span>
        )}
      </div>
    )
  }

  return (
    <div
      className={`inline-editor-display cursor-pointer hover:bg-gray-50 rounded px-2 py-1 ${className}`}
      onClick={startEditing}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          startEditing()
        }
      }}
    >
      {value || <span className="text-gray-500">{placeholder}</span>}
    </div>
  )
}
```

### 태그 편집 시스템

**EditableTags 컴포넌트:**

```typescript
// components/notes/editable-tags.tsx
interface EditableTagsProps {
  tags: string[]
  onTagsChange: (newTags: string[]) => Promise<void>
  maxTags?: number
  readOnly?: boolean
}

export function EditableTags({
  tags,
  onTagsChange,
  maxTags = 6,
  readOnly = false
}: EditableTagsProps) {
  const [localTags, setLocalTags] = useState(tags)
  const [newTagInput, setNewTagInput] = useState('')
  const [editingIndex, setEditingIndex] = useState<number | null>(null)
  const [draggedIndex, setDraggedIndex] = useState<number | null>(null)

  // 드래그앤드롭 핸들러
  const handleDragStart = (index: number) => {
    setDraggedIndex(index)
  }

  const handleDragOver = (e: React.DragEvent, index: number) => {
    e.preventDefault()
    if (draggedIndex === null) return

    const newTags = [...localTags]
    const draggedTag = newTags[draggedIndex]
    newTags.splice(draggedIndex, 1)
    newTags.splice(index, 0, draggedTag)
    
    setLocalTags(newTags)
    setDraggedIndex(index)
  }

  const handleDragEnd = () => {
    if (draggedIndex !== null) {
      onTagsChange(localTags)
    }
    setDraggedIndex(null)
  }

  // 태그 편집
  const handleTagEdit = async (index: number, newValue: string) => {
    const newTags = [...localTags]
    newTags[index] = newValue
    setLocalTags(newTags)
    await onTagsChange(newTags)
    setEditingIndex(null)
  }

  // 태그 삭제
  const handleTagDelete = async (index: number) => {
    const newTags = localTags.filter((_, i) => i !== index)
    setLocalTags(newTags)
    await onTagsChange(newTags)
  }

  // 새 태그 추가
  const handleAddTag = async () => {
    const trimmedTag = newTagInput.trim()
    if (!trimmedTag || localTags.includes(trimmedTag) || localTags.length >= maxTags) {
      return
    }

    const newTags = [...localTags, trimmedTag]
    setLocalTags(newTags)
    setNewTagInput('')
    await onTagsChange(newTags)
  }

  return (
    <div className="editable-tags">
      <div className="flex flex-wrap gap-2 mb-3">
        {localTags.map((tag, index) => (
          <div
            key={index}
            className="tag-item flex items-center bg-blue-50 border border-blue-200 rounded-full px-3 py-1"
            draggable={!readOnly}
            onDragStart={() => handleDragStart(index)}
            onDragOver={(e) => handleDragOver(e, index)}
            onDragEnd={handleDragEnd}
          >
            {editingIndex === index ? (
              <input
                type="text"
                value={tag}
                onChange={(e) => {
                  const newTags = [...localTags]
                  newTags[index] = e.target.value
                  setLocalTags(newTags)
                }}
                onBlur={() => handleTagEdit(index, localTags[index])}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    handleTagEdit(index, localTags[index])
                  } else if (e.key === 'Escape') {
                    setEditingIndex(null)
                    setLocalTags(tags) // 원래 값으로 복원
                  }
                }}
                className="bg-transparent border-none outline-none text-sm"
                autoFocus
              />
            ) : (
              <span
                className="text-sm text-blue-700 cursor-pointer"
                onClick={() => !readOnly && setEditingIndex(index)}
              >
                {tag}
              </span>
            )}
            
            {!readOnly && (
              <button
                onClick={() => handleTagDelete(index)}
                className="ml-1 text-blue-500 hover:text-red-500 transition-colors"
              >
                <X className="h-3 w-3" />
              </button>
            )}
          </div>
        ))}
      </div>

      {!readOnly && localTags.length < maxTags && (
        <div className="add-tag-input flex items-center gap-2">
          <input
            type="text"
            value={newTagInput}
            onChange={(e) => setNewTagInput(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter') {
                handleAddTag()
              }
            }}
            placeholder="새 태그 추가..."
            className="flex-1 text-sm border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
            maxLength={20}
          />
          <button
            onClick={handleAddTag}
            disabled={!newTagInput.trim() || localTags.includes(newTagInput.trim())}
            className="text-sm bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            추가
          </button>
        </div>
      )}
    </div>
  )
}
```

### 자동 저장 시스템

**AutoSave Hook:**

```typescript
// lib/hooks/use-auto-save.ts
interface AutoSaveOptions {
  delay?: number
  onSave: (value: any) => Promise<void>
  onError?: (error: Error) => void
}

export function useAutoSave<T>(
  value: T,
  options: AutoSaveOptions
) {
  const { delay = 1000, onSave, onError } = options
  const [isSaving, setIsSaving] = useState(false)
  const [lastSaved, setLastSaved] = useState<T>(value)
  const saveTimeoutRef = useRef<NodeJS.Timeout>()

  const save = useCallback(async (valueToSave: T) => {
    setIsSaving(true)
    try {
      await onSave(valueToSave)
      setLastSaved(valueToSave)
    } catch (error) {
      onError?.(error as Error)
    } finally {
      setIsSaving(false)
    }
  }, [onSave, onError])

  useEffect(() => {
    if (JSON.stringify(value) === JSON.stringify(lastSaved)) {
      return
    }

    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current)
    }

    saveTimeoutRef.current = setTimeout(() => {
      save(value)
    }, delay)

    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current)
      }
    }
  }, [value, lastSaved, delay, save])

  return {
    isSaving,
    hasUnsavedChanges: JSON.stringify(value) !== JSON.stringify(lastSaved),
    saveNow: () => save(value)
  }
}
```

### 편집 히스토리 관리

**EditHistory 서비스:**

```typescript
// lib/ai/edit-history.ts
export interface EditHistoryEntry {
  id: string
  noteId: string
  type: 'summary' | 'tags'
  previousValue: any
  newValue: any
  editType: 'manual_edit' | 'ai_generation' | 'regeneration'
  userId: string
  createdAt: Date
}

export class EditHistoryService {
  static async recordEdit(entry: Omit<EditHistoryEntry, 'id' | 'createdAt'>) {
    await db.insert(aiEditHistory).values({
      noteId: entry.noteId,
      type: entry.type,
      previousValue: entry.previousValue,
      newValue: entry.newValue,
      editType: entry.editType,
      userId: entry.userId
    })
  }

  static async getHistory(noteId: string, type?: 'summary' | 'tags'): Promise<EditHistoryEntry[]> {
    const query = db
      .select()
      .from(aiEditHistory)
      .where(eq(aiEditHistory.noteId, noteId))
      .orderBy(desc(aiEditHistory.createdAt))

    if (type) {
      query.where(and(
        eq(aiEditHistory.noteId, noteId),
        eq(aiEditHistory.type, type)
      ))
    }

    return query
  }

  static async revertToVersion(
    noteId: string,
    historyId: string,
    userId: string
  ): Promise<void> {
    const historyEntry = await db
      .select()
      .from(aiEditHistory)
      .where(eq(aiEditHistory.id, historyId))
      .limit(1)

    if (!historyEntry[0]) {
      throw new Error('히스토리를 찾을 수 없습니다.')
    }

    const entry = historyEntry[0]
    
    // 현재 값을 백업하고 이전 값으로 복원
    const currentNote = await db
      .select()
      .from(notes)
      .where(eq(notes.id, noteId))
      .limit(1)

    if (!currentNote[0]) {
      throw new Error('노트를 찾을 수 없습니다.')
    }

    const currentValue = currentNote[0][entry.type as keyof typeof currentNote[0]]

    // 복원 실행
    await db.transaction(async (tx) => {
      // 1. 노트 업데이트
      await tx
        .update(notes)
        .set({
          [entry.type]: entry.previousValue,
          updatedAt: new Date()
        })
        .where(eq(notes.id, noteId))

      // 2. 복원 히스토리 기록
      await tx.insert(aiEditHistory).values({
        noteId,
        type: entry.type,
        previousValue: currentValue,
        newValue: entry.previousValue,
        editType: 'manual_edit',
        userId
      })
    })
  }
}
```

### 히스토리 UI 컴포넌트

**EditHistoryDialog:**

```typescript
// components/ai/edit-history-dialog.tsx
interface EditHistoryDialogProps {
  isOpen: boolean
  onClose: () => void
  noteId: string
  type: 'summary' | 'tags'
  onRevert: (historyId: string) => void
}

export function EditHistoryDialog({
  isOpen,
  onClose,
  noteId,
  type,
  onRevert
}: EditHistoryDialogProps) {
  const [history, setHistory] = useState<EditHistoryEntry[]>([])
  const [isLoading, setIsLoading] = useState(false)

  useEffect(() => {
    if (isOpen) {
      loadHistory()
    }
  }, [isOpen])

  const loadHistory = async () => {
    setIsLoading(true)
    try {
      const historyData = await EditHistoryService.getHistory(noteId, type)
      setHistory(historyData)
    } catch (error) {
      console.error('히스토리 로드 실패:', error)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>
            {type === 'summary' ? '요약' : '태그'} 편집 히스토리
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          {isLoading ? (
            <div className="text-center py-8">
              <Loader2 className="h-6 w-6 animate-spin mx-auto" />
              <p className="text-sm text-gray-500 mt-2">히스토리를 불러오는 중...</p>
            </div>
          ) : history.length === 0 ? (
            <p className="text-center text-gray-500 py-8">
              편집 히스토리가 없습니다.
            </p>
          ) : (
            history.map((entry) => (
              <div
                key={entry.id}
                className="border rounded-lg p-4 hover:bg-gray-50"
              >
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <span className={`px-2 py-1 rounded-full text-xs ${
                      entry.editType === 'ai_generation' ? 'bg-purple-100 text-purple-800' :
                      entry.editType === 'regeneration' ? 'bg-blue-100 text-blue-800' :
                      'bg-green-100 text-green-800'
                    }`}>
                      {entry.editType === 'ai_generation' ? 'AI 생성' :
                       entry.editType === 'regeneration' ? '재생성' : '수동 편집'}
                    </span>
                    <span className="text-sm text-gray-500">
                      {formatRelativeTime(entry.createdAt)}
                    </span>
                  </div>
                  <button
                    onClick={() => onRevert(entry.id)}
                    className="text-sm text-blue-600 hover:text-blue-800"
                  >
                    이 버전으로 복원
                  </button>
                </div>

                <div className="text-sm">
                  <div className="mb-2">
                    <span className="font-medium text-gray-700">이전:</span>
                    <div className="mt-1 p-2 bg-red-50 rounded border-l-4 border-red-200">
                      {type === 'summary' ? (
                        <p>{entry.previousValue}</p>
                      ) : (
                        <div className="flex flex-wrap gap-1">
                          {entry.previousValue.map((tag: string, index: number) => (
                            <span key={index} className="bg-red-100 text-red-800 px-2 py-1 rounded-full text-xs">
                              {tag}
                            </span>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>

                  <div>
                    <span className="font-medium text-gray-700">변경:</span>
                    <div className="mt-1 p-2 bg-green-50 rounded border-l-4 border-green-200">
                      {type === 'summary' ? (
                        <p>{entry.newValue}</p>
                      ) : (
                        <div className="flex flex-wrap gap-1">
                          {entry.newValue.map((tag: string, index: number) => (
                            <span key={index} className="bg-green-100 text-green-800 px-2 py-1 rounded-full text-xs">
                              {tag}
                            </span>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            ))
          )}
        </div>
      </DialogContent>
    </Dialog>
  )
}
```

### 기존 컴포넌트 통합

**SummaryGenerator 확장:**

```typescript
// components/notes/summary-generator.tsx (기존 컴포넌트 확장)
export function SummaryGenerator({ 
  noteId, 
  content, 
  existingSummary,
  onSummaryGenerated 
}: SummaryGeneratorProps) {
  const [showHistory, setShowHistory] = useState(false)

  const handleSummaryEdit = async (newSummary: string) => {
    // 편집 히스토리 기록
    if (existingSummary) {
      await EditHistoryService.recordEdit({
        noteId,
        type: 'summary',
        previousValue: existingSummary,
        newValue: newSummary,
        editType: 'manual_edit',
        userId: user.id
      })
    }

    // 데이터베이스 업데이트
    await updateNoteSummary(noteId, newSummary)
    onSummaryGenerated(newSummary)
  }

  return (
    <div className="summary-generator">
      {/* 기존 UI... */}
      
      {existingSummary && (
        <div className="summary-display">
          <div className="flex items-center justify-between mb-2">
            <h4 className="font-medium text-gray-700">AI 요약</h4>
            <button
              onClick={() => setShowHistory(true)}
              className="text-sm text-gray-500 hover:text-gray-700"
            >
              히스토리 보기
            </button>
          </div>
          
          <InlineEditor
            value={existingSummary}
            onSave={handleSummaryEdit}
            placeholder="요약을 클릭하여 편집하세요"
            multiline={true}
            className="summary-editor"
          />
        </div>
      )}

      <EditHistoryDialog
        isOpen={showHistory}
        onClose={() => setShowHistory(false)}
        noteId={noteId}
        type="summary"
        onRevert={async (historyId) => {
          await EditHistoryService.revertToVersion(noteId, historyId, user.id)
          // 페이지 새로고침 또는 상태 업데이트
        }}
      />
    </div>
  )
}
```

## Change Log

| Date       | Version | Description | Author                    |
| ---------- | ------- | ----------- | ------------------------- |
| 2025-09-17 | 1.0     | 스토리 생성 | Scrum Master Bob Claude 4 Sonnet |

## Dev Agent Record

이 섹션은 개발 에이전트가 구현 중에 채워집니다.

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results

QA 에이전트가 완료된 스토리 구현을 검토한 결과입니다.
