# Story 4.7: AI 처리 에러 핸들링

## Status

Draft

## Story

**As a** 사용자,
**I want** AI 요약 및 태그 생성 과정에서 발생하는 다양한 에러 상황에 대한 명확한 안내와 해결 방법,
**so that** 에러 발생 시에도 적절한 대응을 통해 원하는 결과를 얻을 수 있다.

## Acceptance Criteria

1. 네트워크 연결 오류 시 재시도 옵션이 제공되어야 한다
2. API 할당량 초과 시 구체적인 안내 메시지가 표시되어야 한다
3. 노트 내용이 너무 짧거나 길 때 적절한 가이드가 제공되어야 한다
4. 서버 오류 시 자동 재시도 후 실패하면 수동 재시도 옵션을 제공해야 한다
5. 타임아웃 발생 시 처리 시간 안내와 함께 재시도 옵션을 제공해야 한다
6. 부적절한 콘텐츠 감지 시 수정 가이드를 제공해야 한다
7. 에러 발생 시 사용자가 이해하기 쉬운 한국어 메시지로 표시되어야 한다
8. 에러 로그가 서버에 자동으로 기록되어야 한다
9. 반복적인 에러 발생 시 시스템 관리자에게 알림이 전송되어야 한다
10. 에러 복구 후 이전 작업 상태로 자동 복원되어야 한다

## Tasks / Subtasks

- [ ] 에러 타입 정의 및 분류 (AC: 1, 2, 3, 4, 5, 6)
  - [ ] AI 에러 타입 enum 정의
  - [ ] 에러별 메시지 매핑 시스템
  - [ ] 에러 심각도 분류
  - [ ] 복구 가능성 판단 로직
- [ ] 에러 UI 컴포넌트 구현 (AC: 7, 10)
  - [ ] 에러 메시지 컴포넌트
  - [ ] 재시도 버튼 컴포넌트
  - [ ] 에러 상세 정보 모달
  - [ ] 복구 가이드 컴포넌트
- [ ] 자동 재시도 시스템 (AC: 4, 5)
  - [ ] 지수 백오프 재시도 로직
  - [ ] 재시도 횟수 제한
  - [ ] 재시도 간격 조정
  - [ ] 재시도 상태 표시
- [ ] 에러 로깅 및 모니터링 (AC: 8, 9)
  - [ ] 에러 로깅 시스템
  - [ ] 에러 통계 수집
  - [ ] 알림 시스템 연동
  - [ ] 에러 대시보드

## Dev Notes

### 에러 타입 정의

**AI 에러 분류:**

```typescript
// lib/ai/errors.ts
export enum AIErrorType {
  // 네트워크 관련
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT = 'TIMEOUT',
  CONNECTION_FAILED = 'CONNECTION_FAILED',
  
  // API 관련
  API_QUOTA_EXCEEDED = 'API_QUOTA_EXCEEDED',
  API_KEY_INVALID = 'API_KEY_INVALID',
  API_RATE_LIMITED = 'API_RATE_LIMITED',
  
  // 콘텐츠 관련
  CONTENT_TOO_SHORT = 'CONTENT_TOO_SHORT',
  CONTENT_TOO_LONG = 'CONTENT_TOO_LONG',
  CONTENT_INAPPROPRIATE = 'CONTENT_INAPPROPRIATE',
  CONTENT_UNSUPPORTED = 'CONTENT_UNSUPPORTED',
  
  // 서버 관련
  SERVER_ERROR = 'SERVER_ERROR',
  DATABASE_ERROR = 'DATABASE_ERROR',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  
  // 권한 관련
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  USER_NOT_AUTHENTICATED = 'USER_NOT_AUTHENTICATED',
  
  // 기타
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
  PARSING_ERROR = 'PARSING_ERROR'
}

export interface AIError {
  type: AIErrorType
  message: string
  details?: string
  retryable: boolean
  severity: 'low' | 'medium' | 'high' | 'critical'
  suggestedAction?: string
  timestamp: Date
  requestId?: string
}

export class AIErrorHandler {
  private static errorMessages: Record<AIErrorType, string> = {
    [AIErrorType.NETWORK_ERROR]: '네트워크 연결을 확인해주세요.',
    [AIErrorType.TIMEOUT]: '처리 시간이 초과되었습니다. 잠시 후 다시 시도해주세요.',
    [AIErrorType.CONNECTION_FAILED]: '서버에 연결할 수 없습니다.',
    [AIErrorType.API_QUOTA_EXCEEDED]: 'AI 서비스 할당량이 초과되었습니다. 내일 다시 시도해주세요.',
    [AIErrorType.API_KEY_INVALID]: 'AI 서비스 설정에 문제가 있습니다. 관리자에게 문의해주세요.',
    [AIErrorType.API_RATE_LIMITED]: '요청이 너무 많습니다. 잠시 후 다시 시도해주세요.',
    [AIErrorType.CONTENT_TOO_SHORT]: '내용이 너무 짧습니다. 최소 50자 이상 작성해주세요.',
    [AIErrorType.CONTENT_TOO_LONG]: '내용이 너무 깁니다. 8,000자 이하로 줄여주세요.',
    [AIErrorType.CONTENT_INAPPROPRIATE]: '부적절한 내용이 포함되어 있습니다. 내용을 수정해주세요.',
    [AIErrorType.CONTENT_UNSUPPORTED]: '지원하지 않는 형식의 내용입니다.',
    [AIErrorType.SERVER_ERROR]: '서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요.',
    [AIErrorType.DATABASE_ERROR]: '데이터 저장 중 오류가 발생했습니다.',
    [AIErrorType.SERVICE_UNAVAILABLE]: 'AI 서비스를 일시적으로 사용할 수 없습니다.',
    [AIErrorType.PERMISSION_DENIED]: '이 작업을 수행할 권한이 없습니다.',
    [AIErrorType.USER_NOT_AUTHENTICATED]: '로그인이 필요합니다.',
    [AIErrorType.UNKNOWN_ERROR]: '알 수 없는 오류가 발생했습니다.',
    [AIErrorType.PARSING_ERROR]: 'AI 응답을 처리하는 중 오류가 발생했습니다.'
  }

  static createError(
    type: AIErrorType, 
    details?: string, 
    requestId?: string
  ): AIError {
    return {
      type,
      message: this.errorMessages[type],
      details,
      retryable: this.isRetryable(type),
      severity: this.getSeverity(type),
      suggestedAction: this.getSuggestedAction(type),
      timestamp: new Date(),
      requestId
    }
  }

  private static isRetryable(type: AIErrorType): boolean {
    const retryableErrors = [
      AIErrorType.NETWORK_ERROR,
      AIErrorType.TIMEOUT,
      AIErrorType.CONNECTION_FAILED,
      AIErrorType.SERVER_ERROR,
      AIErrorType.SERVICE_UNAVAILABLE,
      AIErrorType.API_RATE_LIMITED
    ]
    return retryableErrors.includes(type)
  }

  private static getSeverity(type: AIErrorType): 'low' | 'medium' | 'high' | 'critical' {
    const severityMap: Record<AIErrorType, 'low' | 'medium' | 'high' | 'critical'> = {
      [AIErrorType.CONTENT_TOO_SHORT]: 'low',
      [AIErrorType.CONTENT_TOO_LONG]: 'low',
      [AIErrorType.NETWORK_ERROR]: 'medium',
      [AIErrorType.TIMEOUT]: 'medium',
      [AIErrorType.API_RATE_LIMITED]: 'medium',
      [AIErrorType.CONTENT_INAPPROPRIATE]: 'medium',
      [AIErrorType.CONTENT_UNSUPPORTED]: 'medium',
      [AIErrorType.CONNECTION_FAILED]: 'high',
      [AIErrorType.SERVER_ERROR]: 'high',
      [AIErrorType.DATABASE_ERROR]: 'high',
      [AIErrorType.PERMISSION_DENIED]: 'high',
      [AIErrorType.API_QUOTA_EXCEEDED]: 'critical',
      [AIErrorType.API_KEY_INVALID]: 'critical',
      [AIErrorType.SERVICE_UNAVAILABLE]: 'critical',
      [AIErrorType.USER_NOT_AUTHENTICATED]: 'critical',
      [AIErrorType.UNKNOWN_ERROR]: 'critical',
      [AIErrorType.PARSING_ERROR]: 'critical'
    }
    return severityMap[type]
  }

  private static getSuggestedAction(type: AIErrorType): string {
    const actionMap: Record<AIErrorType, string> = {
      [AIErrorType.NETWORK_ERROR]: '인터넷 연결을 확인하고 다시 시도해주세요.',
      [AIErrorType.TIMEOUT]: '노트 내용을 줄이거나 잠시 후 다시 시도해주세요.',
      [AIErrorType.CONNECTION_FAILED]: '페이지를 새로고침하고 다시 시도해주세요.',
      [AIErrorType.API_QUOTA_EXCEEDED]: '내일 다시 시도하거나 관리자에게 문의해주세요.',
      [AIErrorType.API_RATE_LIMITED]: '1-2분 후 다시 시도해주세요.',
      [AIErrorType.CONTENT_TOO_SHORT]: '노트 내용을 더 자세히 작성해주세요.',
      [AIErrorType.CONTENT_TOO_LONG]: '노트를 여러 개로 나누어 작성해주세요.',
      [AIErrorType.CONTENT_INAPPROPRIATE]: '내용을 검토하고 수정해주세요.',
      [AIErrorType.SERVER_ERROR]: '잠시 후 다시 시도해주세요.',
      [AIErrorType.PERMISSION_DENIED]: '로그인 상태를 확인해주세요.',
      [AIErrorType.USER_NOT_AUTHENTICATED]: '다시 로그인해주세요.',
      [AIErrorType.UNKNOWN_ERROR]: '문제가 지속되면 관리자에게 문의해주세요.'
    }
    return actionMap[type] || '다시 시도해주세요.'
  }
}
```

### 자동 재시도 시스템

**RetryManager 클래스:**

```typescript
// lib/ai/retry-manager.ts
export interface RetryConfig {
  maxRetries: number
  baseDelay: number
  maxDelay: number
  backoffMultiplier: number
  retryCondition: (error: AIError) => boolean
}

export class RetryManager {
  private defaultConfig: RetryConfig = {
    maxRetries: 3,
    baseDelay: 1000,
    maxDelay: 30000,
    backoffMultiplier: 2,
    retryCondition: (error) => error.retryable
  }

  async executeWithRetry<T>(
    operation: () => Promise<T>,
    config: Partial<RetryConfig> = {}
  ): Promise<T> {
    const finalConfig = { ...this.defaultConfig, ...config }
    let lastError: AIError

    for (let attempt = 0; attempt <= finalConfig.maxRetries; attempt++) {
      try {
        return await operation()
      } catch (error) {
        lastError = error instanceof Error 
          ? AIErrorHandler.createError(AIErrorType.UNKNOWN_ERROR, error.message)
          : error as AIError

        // 마지막 시도이거나 재시도 불가능한 에러면 즉시 실패
        if (attempt === finalConfig.maxRetries || !finalConfig.retryCondition(lastError)) {
          throw lastError
        }

        // 재시도 전 대기
        const delay = Math.min(
          finalConfig.baseDelay * Math.pow(finalConfig.backoffMultiplier, attempt),
          finalConfig.maxDelay
        )

        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }

    throw lastError!
  }

  calculateNextRetryDelay(attempt: number, config: Partial<RetryConfig> = {}): number {
    const finalConfig = { ...this.defaultConfig, ...config }
    return Math.min(
      finalConfig.baseDelay * Math.pow(finalConfig.backoffMultiplier, attempt),
      finalConfig.maxDelay
    )
  }
}
```

### 에러 UI 컴포넌트

**ErrorDisplay 컴포넌트:**

```typescript
// components/ai/error-display.tsx
interface ErrorDisplayProps {
  error: AIError
  onRetry?: () => void
  onDismiss?: () => void
  showDetails?: boolean
}

export function ErrorDisplay({
  error,
  onRetry,
  onDismiss,
  showDetails = false
}: ErrorDisplayProps) {
  const [showDetailModal, setShowDetailModal] = useState(false)

  const getErrorIcon = (severity: string) => {
    switch (severity) {
      case 'low':
        return <Info className="h-5 w-5 text-blue-500" />
      case 'medium':
        return <AlertTriangle className="h-5 w-5 text-yellow-500" />
      case 'high':
        return <AlertCircle className="h-5 w-5 text-orange-500" />
      case 'critical':
        return <XCircle className="h-5 w-5 text-red-500" />
      default:
        return <AlertCircle className="h-5 w-5 text-gray-500" />
    }
  }

  const getErrorBgColor = (severity: string) => {
    switch (severity) {
      case 'low':
        return 'bg-blue-50 border-blue-200'
      case 'medium':
        return 'bg-yellow-50 border-yellow-200'
      case 'high':
        return 'bg-orange-50 border-orange-200'
      case 'critical':
        return 'bg-red-50 border-red-200'
      default:
        return 'bg-gray-50 border-gray-200'
    }
  }

  return (
    <>
      <div className={`error-display p-4 rounded-lg border ${getErrorBgColor(error.severity)}`}>
        <div className="flex items-start gap-3">
          {getErrorIcon(error.severity)}
          
          <div className="flex-1">
            <div className="flex items-center justify-between mb-2">
              <h4 className="font-medium text-gray-900">
                오류가 발생했습니다
              </h4>
              {onDismiss && (
                <button
                  onClick={onDismiss}
                  className="text-gray-400 hover:text-gray-600"
                >
                  <X className="h-4 w-4" />
                </button>
              )}
            </div>
            
            <p className="text-sm text-gray-700 mb-3">
              {error.message}
            </p>
            
            {error.suggestedAction && (
              <p className="text-sm text-gray-600 mb-3">
                💡 {error.suggestedAction}
              </p>
            )}
            
            <div className="flex items-center gap-2">
              {error.retryable && onRetry && (
                <button
                  onClick={onRetry}
                  className="text-sm bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 transition-colors"
                >
                  다시 시도
                </button>
              )}
              
              {showDetails && (
                <button
                  onClick={() => setShowDetailModal(true)}
                  className="text-sm text-gray-600 hover:text-gray-800 underline"
                >
                  자세히 보기
                </button>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* 에러 상세 정보 모달 */}
      <Dialog open={showDetailModal} onOpenChange={setShowDetailModal}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>에러 상세 정보</DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <label className="text-sm font-medium text-gray-700">에러 타입:</label>
              <p className="text-sm text-gray-600">{error.type}</p>
            </div>
            
            <div>
              <label className="text-sm font-medium text-gray-700">심각도:</label>
              <p className="text-sm text-gray-600">{error.severity}</p>
            </div>
            
            <div>
              <label className="text-sm font-medium text-gray-700">발생 시간:</label>
              <p className="text-sm text-gray-600">{error.timestamp.toLocaleString()}</p>
            </div>
            
            {error.details && (
              <div>
                <label className="text-sm font-medium text-gray-700">상세 정보:</label>
                <p className="text-sm text-gray-600 bg-gray-50 p-2 rounded">
                  {error.details}
                </p>
              </div>
            )}
            
            {error.requestId && (
              <div>
                <label className="text-sm font-medium text-gray-700">요청 ID:</label>
                <p className="text-sm text-gray-600 font-mono">{error.requestId}</p>
              </div>
            )}
          </div>
        </DialogContent>
      </Dialog>
    </>
  )
}
```

### 에러 로깅 시스템

**ErrorLogger 클래스:**

```typescript
// lib/ai/error-logger.ts
export interface ErrorLogEntry {
  id: string
  userId?: string
  sessionId: string
  errorType: AIErrorType
  message: string
  details?: string
  stack?: string
  userAgent: string
  url: string
  timestamp: Date
  resolved: boolean
  severity: string
}

export class ErrorLogger {
  private static instance: ErrorLogger
  private sessionId: string
  private logQueue: ErrorLogEntry[] = []
  private isFlushingLogs = false

  constructor() {
    this.sessionId = this.generateSessionId()
    this.startPeriodicFlush()
  }

  static getInstance(): ErrorLogger {
    if (!ErrorLogger.instance) {
      ErrorLogger.instance = new ErrorLogger()
    }
    return ErrorLogger.instance
  }

  async logError(error: AIError, context?: any): Promise<void> {
    const logEntry: ErrorLogEntry = {
      id: crypto.randomUUID(),
      userId: context?.userId,
      sessionId: this.sessionId,
      errorType: error.type,
      message: error.message,
      details: error.details,
      stack: context?.stack,
      userAgent: navigator.userAgent,
      url: window.location.href,
      timestamp: error.timestamp,
      resolved: false,
      severity: error.severity
    }

    // 로컬 큐에 추가
    this.logQueue.push(logEntry)

    // 중요한 에러는 즉시 전송
    if (error.severity === 'critical' || error.severity === 'high') {
      await this.flushLogs()
    }
  }

  private async flushLogs(): Promise<void> {
    if (this.isFlushingLogs || this.logQueue.length === 0) {
      return
    }

    this.isFlushingLogs = true
    const logsToSend = [...this.logQueue]
    this.logQueue = []

    try {
      await fetch('/api/errors/log', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ logs: logsToSend })
      })
    } catch (error) {
      // 로그 전송 실패 시 다시 큐에 추가
      this.logQueue.unshift(...logsToSend)
      console.warn('에러 로그 전송 실패:', error)
    } finally {
      this.isFlushingLogs = false
    }
  }

  private startPeriodicFlush(): void {
    // 30초마다 로그 전송
    setInterval(() => {
      this.flushLogs()
    }, 30000)

    // 페이지 언로드 시 남은 로그 전송
    window.addEventListener('beforeunload', () => {
      if (this.logQueue.length > 0) {
        navigator.sendBeacon('/api/errors/log', JSON.stringify({
          logs: this.logQueue
        }))
      }
    })
  }

  private generateSessionId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
  }
}
```

### 에러 로깅 API

**에러 로그 API 엔드포인트:**

```typescript
// app/api/errors/log/route.ts
export async function POST(request: NextRequest) {
  try {
    const { logs } = await request.json()

    // 데이터베이스에 에러 로그 저장
    await db.insert(errorLogs).values(
      logs.map((log: ErrorLogEntry) => ({
        id: log.id,
        userId: log.userId,
        sessionId: log.sessionId,
        errorType: log.errorType,
        message: log.message,
        details: log.details,
        stack: log.stack,
        userAgent: log.userAgent,
        url: log.url,
        timestamp: log.timestamp,
        resolved: log.resolved,
        severity: log.severity
      }))
    )

    // 중요한 에러는 알림 전송
    const criticalErrors = logs.filter((log: ErrorLogEntry) => 
      log.severity === 'critical'
    )

    if (criticalErrors.length > 0) {
      await sendCriticalErrorAlert(criticalErrors)
    }

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('에러 로그 저장 실패:', error)
    return NextResponse.json(
      { error: '로그 저장 실패' },
      { status: 500 }
    )
  }
}

async function sendCriticalErrorAlert(errors: ErrorLogEntry[]): Promise<void> {
  // 슬랙, 이메일 등으로 알림 전송
  // 구현은 프로젝트 요구사항에 따라 결정
}
```

### 통합 사용 예시

**AI 서비스에서 에러 핸들링:**

```typescript
// lib/ai/ai-service.ts
export class AIService {
  private retryManager = new RetryManager()
  private errorLogger = ErrorLogger.getInstance()

  async generateSummary(content: string, noteId: string): Promise<string> {
    try {
      return await this.retryManager.executeWithRetry(async () => {
        // 콘텐츠 길이 검증
        if (content.length < 50) {
          throw AIErrorHandler.createError(
            AIErrorType.CONTENT_TOO_SHORT,
            `콘텐츠 길이: ${content.length}자`
          )
        }

        if (content.length > 8000) {
          throw AIErrorHandler.createError(
            AIErrorType.CONTENT_TOO_LONG,
            `콘텐츠 길이: ${content.length}자`
          )
        }

        // AI API 호출
        const response = await fetch('/api/ai/summarize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content, noteId })
        })

        if (!response.ok) {
          const errorData = await response.json()
          throw this.mapHttpErrorToAIError(response.status, errorData)
        }

        const result = await response.json()
        return result.summary
      })
    } catch (error) {
      const aiError = error as AIError
      
      // 에러 로깅
      await this.errorLogger.logError(aiError, {
        noteId,
        contentLength: content.length,
        userId: 'current-user-id' // 실제 구현에서는 현재 사용자 ID
      })

      throw aiError
    }
  }

  private mapHttpErrorToAIError(status: number, errorData: any): AIError {
    switch (status) {
      case 429:
        return AIErrorHandler.createError(AIErrorType.API_RATE_LIMITED)
      case 413:
        return AIErrorHandler.createError(AIErrorType.CONTENT_TOO_LONG)
      case 400:
        return AIErrorHandler.createError(AIErrorType.CONTENT_INAPPROPRIATE)
      case 401:
        return AIErrorHandler.createError(AIErrorType.USER_NOT_AUTHENTICATED)
      case 403:
        return AIErrorHandler.createError(AIErrorType.PERMISSION_DENIED)
      case 500:
        return AIErrorHandler.createError(AIErrorType.SERVER_ERROR)
      case 503:
        return AIErrorHandler.createError(AIErrorType.SERVICE_UNAVAILABLE)
      default:
        return AIErrorHandler.createError(
          AIErrorType.UNKNOWN_ERROR,
          errorData?.message || `HTTP ${status} 에러`
        )
    }
  }
}
```

## Change Log

| Date       | Version | Description | Author                    |
| ---------- | ------- | ----------- | ------------------------- |
| 2025-09-17 | 1.0     | 스토리 생성 | Scrum Master Bob Claude 4 Sonnet |

## Dev Agent Record

이 섹션은 개발 에이전트가 구현 중에 채워집니다.

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results

QA 에이전트가 완료된 스토리 구현을 검토한 결과입니다.
