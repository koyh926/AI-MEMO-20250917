# Story 4.7: AI ì²˜ë¦¬ ì—ëŸ¬ í•¸ë“¤ë§

## Status

Draft

## Story

**As a** ì‚¬ìš©ì,
**I want** AI ìš”ì•½ ë° íƒœê·¸ ìƒì„± ê³¼ì •ì—ì„œ ë°œìƒí•˜ëŠ” ë‹¤ì–‘í•œ ì—ëŸ¬ ìƒí™©ì— ëŒ€í•œ ëª…í™•í•œ ì•ˆë‚´ì™€ í•´ê²° ë°©ë²•,
**so that** ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ ì ì ˆí•œ ëŒ€ì‘ì„ í†µí•´ ì›í•˜ëŠ” ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤.

## Acceptance Criteria

1. ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì˜¤ë¥˜ ì‹œ ì¬ì‹œë„ ì˜µì…˜ì´ ì œê³µë˜ì–´ì•¼ í•œë‹¤
2. API í• ë‹¹ëŸ‰ ì´ˆê³¼ ì‹œ êµ¬ì²´ì ì¸ ì•ˆë‚´ ë©”ì‹œì§€ê°€ í‘œì‹œë˜ì–´ì•¼ í•œë‹¤
3. ë…¸íŠ¸ ë‚´ìš©ì´ ë„ˆë¬´ ì§§ê±°ë‚˜ ê¸¸ ë•Œ ì ì ˆí•œ ê°€ì´ë“œê°€ ì œê³µë˜ì–´ì•¼ í•œë‹¤
4. ì„œë²„ ì˜¤ë¥˜ ì‹œ ìë™ ì¬ì‹œë„ í›„ ì‹¤íŒ¨í•˜ë©´ ìˆ˜ë™ ì¬ì‹œë„ ì˜µì…˜ì„ ì œê³µí•´ì•¼ í•œë‹¤
5. íƒ€ì„ì•„ì›ƒ ë°œìƒ ì‹œ ì²˜ë¦¬ ì‹œê°„ ì•ˆë‚´ì™€ í•¨ê»˜ ì¬ì‹œë„ ì˜µì…˜ì„ ì œê³µí•´ì•¼ í•œë‹¤
6. ë¶€ì ì ˆí•œ ì½˜í…ì¸  ê°ì§€ ì‹œ ìˆ˜ì • ê°€ì´ë“œë¥¼ ì œê³µí•´ì•¼ í•œë‹¤
7. ì—ëŸ¬ ë°œìƒ ì‹œ ì‚¬ìš©ìê°€ ì´í•´í•˜ê¸° ì‰¬ìš´ í•œêµ­ì–´ ë©”ì‹œì§€ë¡œ í‘œì‹œë˜ì–´ì•¼ í•œë‹¤
8. ì—ëŸ¬ ë¡œê·¸ê°€ ì„œë²„ì— ìë™ìœ¼ë¡œ ê¸°ë¡ë˜ì–´ì•¼ í•œë‹¤
9. ë°˜ë³µì ì¸ ì—ëŸ¬ ë°œìƒ ì‹œ ì‹œìŠ¤í…œ ê´€ë¦¬ìì—ê²Œ ì•Œë¦¼ì´ ì „ì†¡ë˜ì–´ì•¼ í•œë‹¤
10. ì—ëŸ¬ ë³µêµ¬ í›„ ì´ì „ ì‘ì—… ìƒíƒœë¡œ ìë™ ë³µì›ë˜ì–´ì•¼ í•œë‹¤

## Tasks / Subtasks

- [ ] ì—ëŸ¬ íƒ€ì… ì •ì˜ ë° ë¶„ë¥˜ (AC: 1, 2, 3, 4, 5, 6)
  - [ ] AI ì—ëŸ¬ íƒ€ì… enum ì •ì˜
  - [ ] ì—ëŸ¬ë³„ ë©”ì‹œì§€ ë§¤í•‘ ì‹œìŠ¤í…œ
  - [ ] ì—ëŸ¬ ì‹¬ê°ë„ ë¶„ë¥˜
  - [ ] ë³µêµ¬ ê°€ëŠ¥ì„± íŒë‹¨ ë¡œì§
- [ ] ì—ëŸ¬ UI ì»´í¬ë„ŒíŠ¸ êµ¬í˜„ (AC: 7, 10)
  - [ ] ì—ëŸ¬ ë©”ì‹œì§€ ì»´í¬ë„ŒíŠ¸
  - [ ] ì¬ì‹œë„ ë²„íŠ¼ ì»´í¬ë„ŒíŠ¸
  - [ ] ì—ëŸ¬ ìƒì„¸ ì •ë³´ ëª¨ë‹¬
  - [ ] ë³µêµ¬ ê°€ì´ë“œ ì»´í¬ë„ŒíŠ¸
- [ ] ìë™ ì¬ì‹œë„ ì‹œìŠ¤í…œ (AC: 4, 5)
  - [ ] ì§€ìˆ˜ ë°±ì˜¤í”„ ì¬ì‹œë„ ë¡œì§
  - [ ] ì¬ì‹œë„ íšŸìˆ˜ ì œí•œ
  - [ ] ì¬ì‹œë„ ê°„ê²© ì¡°ì •
  - [ ] ì¬ì‹œë„ ìƒíƒœ í‘œì‹œ
- [ ] ì—ëŸ¬ ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§ (AC: 8, 9)
  - [ ] ì—ëŸ¬ ë¡œê¹… ì‹œìŠ¤í…œ
  - [ ] ì—ëŸ¬ í†µê³„ ìˆ˜ì§‘
  - [ ] ì•Œë¦¼ ì‹œìŠ¤í…œ ì—°ë™
  - [ ] ì—ëŸ¬ ëŒ€ì‹œë³´ë“œ

## Dev Notes

### ì—ëŸ¬ íƒ€ì… ì •ì˜

**AI ì—ëŸ¬ ë¶„ë¥˜:**

```typescript
// lib/ai/errors.ts
export enum AIErrorType {
  // ë„¤íŠ¸ì›Œí¬ ê´€ë ¨
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT = 'TIMEOUT',
  CONNECTION_FAILED = 'CONNECTION_FAILED',
  
  // API ê´€ë ¨
  API_QUOTA_EXCEEDED = 'API_QUOTA_EXCEEDED',
  API_KEY_INVALID = 'API_KEY_INVALID',
  API_RATE_LIMITED = 'API_RATE_LIMITED',
  
  // ì½˜í…ì¸  ê´€ë ¨
  CONTENT_TOO_SHORT = 'CONTENT_TOO_SHORT',
  CONTENT_TOO_LONG = 'CONTENT_TOO_LONG',
  CONTENT_INAPPROPRIATE = 'CONTENT_INAPPROPRIATE',
  CONTENT_UNSUPPORTED = 'CONTENT_UNSUPPORTED',
  
  // ì„œë²„ ê´€ë ¨
  SERVER_ERROR = 'SERVER_ERROR',
  DATABASE_ERROR = 'DATABASE_ERROR',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  
  // ê¶Œí•œ ê´€ë ¨
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  USER_NOT_AUTHENTICATED = 'USER_NOT_AUTHENTICATED',
  
  // ê¸°íƒ€
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
  PARSING_ERROR = 'PARSING_ERROR'
}

export interface AIError {
  type: AIErrorType
  message: string
  details?: string
  retryable: boolean
  severity: 'low' | 'medium' | 'high' | 'critical'
  suggestedAction?: string
  timestamp: Date
  requestId?: string
}

export class AIErrorHandler {
  private static errorMessages: Record<AIErrorType, string> = {
    [AIErrorType.NETWORK_ERROR]: 'ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.',
    [AIErrorType.TIMEOUT]: 'ì²˜ë¦¬ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
    [AIErrorType.CONNECTION_FAILED]: 'ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
    [AIErrorType.API_QUOTA_EXCEEDED]: 'AI ì„œë¹„ìŠ¤ í• ë‹¹ëŸ‰ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. ë‚´ì¼ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
    [AIErrorType.API_KEY_INVALID]: 'AI ì„œë¹„ìŠ¤ ì„¤ì •ì— ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”.',
    [AIErrorType.API_RATE_LIMITED]: 'ìš”ì²­ì´ ë„ˆë¬´ ë§ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
    [AIErrorType.CONTENT_TOO_SHORT]: 'ë‚´ìš©ì´ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤. ìµœì†Œ 50ì ì´ìƒ ì‘ì„±í•´ì£¼ì„¸ìš”.',
    [AIErrorType.CONTENT_TOO_LONG]: 'ë‚´ìš©ì´ ë„ˆë¬´ ê¹ë‹ˆë‹¤. 8,000ì ì´í•˜ë¡œ ì¤„ì—¬ì£¼ì„¸ìš”.',
    [AIErrorType.CONTENT_INAPPROPRIATE]: 'ë¶€ì ì ˆí•œ ë‚´ìš©ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ë‚´ìš©ì„ ìˆ˜ì •í•´ì£¼ì„¸ìš”.',
    [AIErrorType.CONTENT_UNSUPPORTED]: 'ì§€ì›í•˜ì§€ ì•ŠëŠ” í˜•ì‹ì˜ ë‚´ìš©ì…ë‹ˆë‹¤.',
    [AIErrorType.SERVER_ERROR]: 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
    [AIErrorType.DATABASE_ERROR]: 'ë°ì´í„° ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
    [AIErrorType.SERVICE_UNAVAILABLE]: 'AI ì„œë¹„ìŠ¤ë¥¼ ì¼ì‹œì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
    [AIErrorType.PERMISSION_DENIED]: 'ì´ ì‘ì—…ì„ ìˆ˜í–‰í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.',
    [AIErrorType.USER_NOT_AUTHENTICATED]: 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.',
    [AIErrorType.UNKNOWN_ERROR]: 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
    [AIErrorType.PARSING_ERROR]: 'AI ì‘ë‹µì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
  }

  static createError(
    type: AIErrorType, 
    details?: string, 
    requestId?: string
  ): AIError {
    return {
      type,
      message: this.errorMessages[type],
      details,
      retryable: this.isRetryable(type),
      severity: this.getSeverity(type),
      suggestedAction: this.getSuggestedAction(type),
      timestamp: new Date(),
      requestId
    }
  }

  private static isRetryable(type: AIErrorType): boolean {
    const retryableErrors = [
      AIErrorType.NETWORK_ERROR,
      AIErrorType.TIMEOUT,
      AIErrorType.CONNECTION_FAILED,
      AIErrorType.SERVER_ERROR,
      AIErrorType.SERVICE_UNAVAILABLE,
      AIErrorType.API_RATE_LIMITED
    ]
    return retryableErrors.includes(type)
  }

  private static getSeverity(type: AIErrorType): 'low' | 'medium' | 'high' | 'critical' {
    const severityMap: Record<AIErrorType, 'low' | 'medium' | 'high' | 'critical'> = {
      [AIErrorType.CONTENT_TOO_SHORT]: 'low',
      [AIErrorType.CONTENT_TOO_LONG]: 'low',
      [AIErrorType.NETWORK_ERROR]: 'medium',
      [AIErrorType.TIMEOUT]: 'medium',
      [AIErrorType.API_RATE_LIMITED]: 'medium',
      [AIErrorType.CONTENT_INAPPROPRIATE]: 'medium',
      [AIErrorType.CONTENT_UNSUPPORTED]: 'medium',
      [AIErrorType.CONNECTION_FAILED]: 'high',
      [AIErrorType.SERVER_ERROR]: 'high',
      [AIErrorType.DATABASE_ERROR]: 'high',
      [AIErrorType.PERMISSION_DENIED]: 'high',
      [AIErrorType.API_QUOTA_EXCEEDED]: 'critical',
      [AIErrorType.API_KEY_INVALID]: 'critical',
      [AIErrorType.SERVICE_UNAVAILABLE]: 'critical',
      [AIErrorType.USER_NOT_AUTHENTICATED]: 'critical',
      [AIErrorType.UNKNOWN_ERROR]: 'critical',
      [AIErrorType.PARSING_ERROR]: 'critical'
    }
    return severityMap[type]
  }

  private static getSuggestedAction(type: AIErrorType): string {
    const actionMap: Record<AIErrorType, string> = {
      [AIErrorType.NETWORK_ERROR]: 'ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
      [AIErrorType.TIMEOUT]: 'ë…¸íŠ¸ ë‚´ìš©ì„ ì¤„ì´ê±°ë‚˜ ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
      [AIErrorType.CONNECTION_FAILED]: 'í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
      [AIErrorType.API_QUOTA_EXCEEDED]: 'ë‚´ì¼ ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”.',
      [AIErrorType.API_RATE_LIMITED]: '1-2ë¶„ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
      [AIErrorType.CONTENT_TOO_SHORT]: 'ë…¸íŠ¸ ë‚´ìš©ì„ ë” ìì„¸íˆ ì‘ì„±í•´ì£¼ì„¸ìš”.',
      [AIErrorType.CONTENT_TOO_LONG]: 'ë…¸íŠ¸ë¥¼ ì—¬ëŸ¬ ê°œë¡œ ë‚˜ëˆ„ì–´ ì‘ì„±í•´ì£¼ì„¸ìš”.',
      [AIErrorType.CONTENT_INAPPROPRIATE]: 'ë‚´ìš©ì„ ê²€í† í•˜ê³  ìˆ˜ì •í•´ì£¼ì„¸ìš”.',
      [AIErrorType.SERVER_ERROR]: 'ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
      [AIErrorType.PERMISSION_DENIED]: 'ë¡œê·¸ì¸ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.',
      [AIErrorType.USER_NOT_AUTHENTICATED]: 'ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.',
      [AIErrorType.UNKNOWN_ERROR]: 'ë¬¸ì œê°€ ì§€ì†ë˜ë©´ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”.'
    }
    return actionMap[type] || 'ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'
  }
}
```

### ìë™ ì¬ì‹œë„ ì‹œìŠ¤í…œ

**RetryManager í´ë˜ìŠ¤:**

```typescript
// lib/ai/retry-manager.ts
export interface RetryConfig {
  maxRetries: number
  baseDelay: number
  maxDelay: number
  backoffMultiplier: number
  retryCondition: (error: AIError) => boolean
}

export class RetryManager {
  private defaultConfig: RetryConfig = {
    maxRetries: 3,
    baseDelay: 1000,
    maxDelay: 30000,
    backoffMultiplier: 2,
    retryCondition: (error) => error.retryable
  }

  async executeWithRetry<T>(
    operation: () => Promise<T>,
    config: Partial<RetryConfig> = {}
  ): Promise<T> {
    const finalConfig = { ...this.defaultConfig, ...config }
    let lastError: AIError

    for (let attempt = 0; attempt <= finalConfig.maxRetries; attempt++) {
      try {
        return await operation()
      } catch (error) {
        lastError = error instanceof Error 
          ? AIErrorHandler.createError(AIErrorType.UNKNOWN_ERROR, error.message)
          : error as AIError

        // ë§ˆì§€ë§‰ ì‹œë„ì´ê±°ë‚˜ ì¬ì‹œë„ ë¶ˆê°€ëŠ¥í•œ ì—ëŸ¬ë©´ ì¦‰ì‹œ ì‹¤íŒ¨
        if (attempt === finalConfig.maxRetries || !finalConfig.retryCondition(lastError)) {
          throw lastError
        }

        // ì¬ì‹œë„ ì „ ëŒ€ê¸°
        const delay = Math.min(
          finalConfig.baseDelay * Math.pow(finalConfig.backoffMultiplier, attempt),
          finalConfig.maxDelay
        )

        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }

    throw lastError!
  }

  calculateNextRetryDelay(attempt: number, config: Partial<RetryConfig> = {}): number {
    const finalConfig = { ...this.defaultConfig, ...config }
    return Math.min(
      finalConfig.baseDelay * Math.pow(finalConfig.backoffMultiplier, attempt),
      finalConfig.maxDelay
    )
  }
}
```

### ì—ëŸ¬ UI ì»´í¬ë„ŒíŠ¸

**ErrorDisplay ì»´í¬ë„ŒíŠ¸:**

```typescript
// components/ai/error-display.tsx
interface ErrorDisplayProps {
  error: AIError
  onRetry?: () => void
  onDismiss?: () => void
  showDetails?: boolean
}

export function ErrorDisplay({
  error,
  onRetry,
  onDismiss,
  showDetails = false
}: ErrorDisplayProps) {
  const [showDetailModal, setShowDetailModal] = useState(false)

  const getErrorIcon = (severity: string) => {
    switch (severity) {
      case 'low':
        return <Info className="h-5 w-5 text-blue-500" />
      case 'medium':
        return <AlertTriangle className="h-5 w-5 text-yellow-500" />
      case 'high':
        return <AlertCircle className="h-5 w-5 text-orange-500" />
      case 'critical':
        return <XCircle className="h-5 w-5 text-red-500" />
      default:
        return <AlertCircle className="h-5 w-5 text-gray-500" />
    }
  }

  const getErrorBgColor = (severity: string) => {
    switch (severity) {
      case 'low':
        return 'bg-blue-50 border-blue-200'
      case 'medium':
        return 'bg-yellow-50 border-yellow-200'
      case 'high':
        return 'bg-orange-50 border-orange-200'
      case 'critical':
        return 'bg-red-50 border-red-200'
      default:
        return 'bg-gray-50 border-gray-200'
    }
  }

  return (
    <>
      <div className={`error-display p-4 rounded-lg border ${getErrorBgColor(error.severity)}`}>
        <div className="flex items-start gap-3">
          {getErrorIcon(error.severity)}
          
          <div className="flex-1">
            <div className="flex items-center justify-between mb-2">
              <h4 className="font-medium text-gray-900">
                ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤
              </h4>
              {onDismiss && (
                <button
                  onClick={onDismiss}
                  className="text-gray-400 hover:text-gray-600"
                >
                  <X className="h-4 w-4" />
                </button>
              )}
            </div>
            
            <p className="text-sm text-gray-700 mb-3">
              {error.message}
            </p>
            
            {error.suggestedAction && (
              <p className="text-sm text-gray-600 mb-3">
                ğŸ’¡ {error.suggestedAction}
              </p>
            )}
            
            <div className="flex items-center gap-2">
              {error.retryable && onRetry && (
                <button
                  onClick={onRetry}
                  className="text-sm bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 transition-colors"
                >
                  ë‹¤ì‹œ ì‹œë„
                </button>
              )}
              
              {showDetails && (
                <button
                  onClick={() => setShowDetailModal(true)}
                  className="text-sm text-gray-600 hover:text-gray-800 underline"
                >
                  ìì„¸íˆ ë³´ê¸°
                </button>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* ì—ëŸ¬ ìƒì„¸ ì •ë³´ ëª¨ë‹¬ */}
      <Dialog open={showDetailModal} onOpenChange={setShowDetailModal}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>ì—ëŸ¬ ìƒì„¸ ì •ë³´</DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <label className="text-sm font-medium text-gray-700">ì—ëŸ¬ íƒ€ì…:</label>
              <p className="text-sm text-gray-600">{error.type}</p>
            </div>
            
            <div>
              <label className="text-sm font-medium text-gray-700">ì‹¬ê°ë„:</label>
              <p className="text-sm text-gray-600">{error.severity}</p>
            </div>
            
            <div>
              <label className="text-sm font-medium text-gray-700">ë°œìƒ ì‹œê°„:</label>
              <p className="text-sm text-gray-600">{error.timestamp.toLocaleString()}</p>
            </div>
            
            {error.details && (
              <div>
                <label className="text-sm font-medium text-gray-700">ìƒì„¸ ì •ë³´:</label>
                <p className="text-sm text-gray-600 bg-gray-50 p-2 rounded">
                  {error.details}
                </p>
              </div>
            )}
            
            {error.requestId && (
              <div>
                <label className="text-sm font-medium text-gray-700">ìš”ì²­ ID:</label>
                <p className="text-sm text-gray-600 font-mono">{error.requestId}</p>
              </div>
            )}
          </div>
        </DialogContent>
      </Dialog>
    </>
  )
}
```

### ì—ëŸ¬ ë¡œê¹… ì‹œìŠ¤í…œ

**ErrorLogger í´ë˜ìŠ¤:**

```typescript
// lib/ai/error-logger.ts
export interface ErrorLogEntry {
  id: string
  userId?: string
  sessionId: string
  errorType: AIErrorType
  message: string
  details?: string
  stack?: string
  userAgent: string
  url: string
  timestamp: Date
  resolved: boolean
  severity: string
}

export class ErrorLogger {
  private static instance: ErrorLogger
  private sessionId: string
  private logQueue: ErrorLogEntry[] = []
  private isFlushingLogs = false

  constructor() {
    this.sessionId = this.generateSessionId()
    this.startPeriodicFlush()
  }

  static getInstance(): ErrorLogger {
    if (!ErrorLogger.instance) {
      ErrorLogger.instance = new ErrorLogger()
    }
    return ErrorLogger.instance
  }

  async logError(error: AIError, context?: any): Promise<void> {
    const logEntry: ErrorLogEntry = {
      id: crypto.randomUUID(),
      userId: context?.userId,
      sessionId: this.sessionId,
      errorType: error.type,
      message: error.message,
      details: error.details,
      stack: context?.stack,
      userAgent: navigator.userAgent,
      url: window.location.href,
      timestamp: error.timestamp,
      resolved: false,
      severity: error.severity
    }

    // ë¡œì»¬ íì— ì¶”ê°€
    this.logQueue.push(logEntry)

    // ì¤‘ìš”í•œ ì—ëŸ¬ëŠ” ì¦‰ì‹œ ì „ì†¡
    if (error.severity === 'critical' || error.severity === 'high') {
      await this.flushLogs()
    }
  }

  private async flushLogs(): Promise<void> {
    if (this.isFlushingLogs || this.logQueue.length === 0) {
      return
    }

    this.isFlushingLogs = true
    const logsToSend = [...this.logQueue]
    this.logQueue = []

    try {
      await fetch('/api/errors/log', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ logs: logsToSend })
      })
    } catch (error) {
      // ë¡œê·¸ ì „ì†¡ ì‹¤íŒ¨ ì‹œ ë‹¤ì‹œ íì— ì¶”ê°€
      this.logQueue.unshift(...logsToSend)
      console.warn('ì—ëŸ¬ ë¡œê·¸ ì „ì†¡ ì‹¤íŒ¨:', error)
    } finally {
      this.isFlushingLogs = false
    }
  }

  private startPeriodicFlush(): void {
    // 30ì´ˆë§ˆë‹¤ ë¡œê·¸ ì „ì†¡
    setInterval(() => {
      this.flushLogs()
    }, 30000)

    // í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ ë‚¨ì€ ë¡œê·¸ ì „ì†¡
    window.addEventListener('beforeunload', () => {
      if (this.logQueue.length > 0) {
        navigator.sendBeacon('/api/errors/log', JSON.stringify({
          logs: this.logQueue
        }))
      }
    })
  }

  private generateSessionId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
  }
}
```

### ì—ëŸ¬ ë¡œê¹… API

**ì—ëŸ¬ ë¡œê·¸ API ì—”ë“œí¬ì¸íŠ¸:**

```typescript
// app/api/errors/log/route.ts
export async function POST(request: NextRequest) {
  try {
    const { logs } = await request.json()

    // ë°ì´í„°ë² ì´ìŠ¤ì— ì—ëŸ¬ ë¡œê·¸ ì €ì¥
    await db.insert(errorLogs).values(
      logs.map((log: ErrorLogEntry) => ({
        id: log.id,
        userId: log.userId,
        sessionId: log.sessionId,
        errorType: log.errorType,
        message: log.message,
        details: log.details,
        stack: log.stack,
        userAgent: log.userAgent,
        url: log.url,
        timestamp: log.timestamp,
        resolved: log.resolved,
        severity: log.severity
      }))
    )

    // ì¤‘ìš”í•œ ì—ëŸ¬ëŠ” ì•Œë¦¼ ì „ì†¡
    const criticalErrors = logs.filter((log: ErrorLogEntry) => 
      log.severity === 'critical'
    )

    if (criticalErrors.length > 0) {
      await sendCriticalErrorAlert(criticalErrors)
    }

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('ì—ëŸ¬ ë¡œê·¸ ì €ì¥ ì‹¤íŒ¨:', error)
    return NextResponse.json(
      { error: 'ë¡œê·¸ ì €ì¥ ì‹¤íŒ¨' },
      { status: 500 }
    )
  }
}

async function sendCriticalErrorAlert(errors: ErrorLogEntry[]): Promise<void> {
  // ìŠ¬ë™, ì´ë©”ì¼ ë“±ìœ¼ë¡œ ì•Œë¦¼ ì „ì†¡
  // êµ¬í˜„ì€ í”„ë¡œì íŠ¸ ìš”êµ¬ì‚¬í•­ì— ë”°ë¼ ê²°ì •
}
```

### í†µí•© ì‚¬ìš© ì˜ˆì‹œ

**AI ì„œë¹„ìŠ¤ì—ì„œ ì—ëŸ¬ í•¸ë“¤ë§:**

```typescript
// lib/ai/ai-service.ts
export class AIService {
  private retryManager = new RetryManager()
  private errorLogger = ErrorLogger.getInstance()

  async generateSummary(content: string, noteId: string): Promise<string> {
    try {
      return await this.retryManager.executeWithRetry(async () => {
        // ì½˜í…ì¸  ê¸¸ì´ ê²€ì¦
        if (content.length < 50) {
          throw AIErrorHandler.createError(
            AIErrorType.CONTENT_TOO_SHORT,
            `ì½˜í…ì¸  ê¸¸ì´: ${content.length}ì`
          )
        }

        if (content.length > 8000) {
          throw AIErrorHandler.createError(
            AIErrorType.CONTENT_TOO_LONG,
            `ì½˜í…ì¸  ê¸¸ì´: ${content.length}ì`
          )
        }

        // AI API í˜¸ì¶œ
        const response = await fetch('/api/ai/summarize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content, noteId })
        })

        if (!response.ok) {
          const errorData = await response.json()
          throw this.mapHttpErrorToAIError(response.status, errorData)
        }

        const result = await response.json()
        return result.summary
      })
    } catch (error) {
      const aiError = error as AIError
      
      // ì—ëŸ¬ ë¡œê¹…
      await this.errorLogger.logError(aiError, {
        noteId,
        contentLength: content.length,
        userId: 'current-user-id' // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” í˜„ì¬ ì‚¬ìš©ì ID
      })

      throw aiError
    }
  }

  private mapHttpErrorToAIError(status: number, errorData: any): AIError {
    switch (status) {
      case 429:
        return AIErrorHandler.createError(AIErrorType.API_RATE_LIMITED)
      case 413:
        return AIErrorHandler.createError(AIErrorType.CONTENT_TOO_LONG)
      case 400:
        return AIErrorHandler.createError(AIErrorType.CONTENT_INAPPROPRIATE)
      case 401:
        return AIErrorHandler.createError(AIErrorType.USER_NOT_AUTHENTICATED)
      case 403:
        return AIErrorHandler.createError(AIErrorType.PERMISSION_DENIED)
      case 500:
        return AIErrorHandler.createError(AIErrorType.SERVER_ERROR)
      case 503:
        return AIErrorHandler.createError(AIErrorType.SERVICE_UNAVAILABLE)
      default:
        return AIErrorHandler.createError(
          AIErrorType.UNKNOWN_ERROR,
          errorData?.message || `HTTP ${status} ì—ëŸ¬`
        )
    }
  }
}
```

## Change Log

| Date       | Version | Description | Author                    |
| ---------- | ------- | ----------- | ------------------------- |
| 2025-09-17 | 1.0     | ìŠ¤í† ë¦¬ ìƒì„± | Scrum Master Bob Claude 4 Sonnet |

## Dev Agent Record

ì´ ì„¹ì…˜ì€ ê°œë°œ ì—ì´ì „íŠ¸ê°€ êµ¬í˜„ ì¤‘ì— ì±„ì›Œì§‘ë‹ˆë‹¤.

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results

QA ì—ì´ì „íŠ¸ê°€ ì™„ë£Œëœ ìŠ¤í† ë¦¬ êµ¬í˜„ì„ ê²€í† í•œ ê²°ê³¼ì…ë‹ˆë‹¤.
