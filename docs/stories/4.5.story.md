# Story 4.5: AI 결과 재생성 기능

## Status

Draft

## Story

**As a** 사용자,
**I want** 생성된 AI 요약이나 태그가 만족스럽지 않을 때 다시 생성할 수 있는 기능,
**so that** 더 적절하고 정확한 AI 결과를 얻을 수 있다.

## Acceptance Criteria

1. 요약이 생성된 노트에서 "요약 재생성" 버튼이 제공되어야 한다
2. 태그가 생성된 노트에서 "태그 재생성" 버튼이 제공되어야 한다
3. 재생성 시 기존 결과를 덮어쓰기 전에 확인 메시지가 표시되어야 한다
4. 재생성 중에는 기존 결과가 유지되고 로딩 상태가 표시되어야 한다
5. 재생성 실패 시 기존 결과가 그대로 유지되어야 한다
6. 재생성 성공 시 새로운 결과로 업데이트되어야 한다
7. 연속적인 재생성 요청을 방지하는 쿨다운 기능이 있어야 한다 (30초)
8. 재생성 버튼은 권한이 있는 사용자(노트 작성자)에게만 표시되어야 한다
9. 재생성 횟수가 일일 제한(10회)을 초과하면 제한 메시지가 표시되어야 한다
10. 재생성 이력이 로그로 기록되어야 한다

## Tasks / Subtasks

- [ ] 재생성 UI 컴포넌트 구현 (AC: 1, 2, 3)
  - [ ] 재생성 버튼 컴포넌트
  - [ ] 확인 다이얼로그 컴포넌트
  - [ ] 권한 체크 로직
  - [ ] 버튼 상태 관리 (활성/비활성)
- [ ] 재생성 API 엔드포인트 구현 (AC: 4, 5, 6)
  - [ ] 요약 재생성 API
  - [ ] 태그 재생성 API
  - [ ] 기존 데이터 백업 및 복구 로직
  - [ ] 트랜잭션 처리
- [ ] 제한 및 보안 기능 (AC: 7, 8, 9)
  - [ ] 쿨다운 타이머 구현
  - [ ] 일일 재생성 횟수 추적
  - [ ] 사용자 권한 검증
  - [ ] 레이트 리미팅
- [ ] 로깅 및 모니터링 (AC: 10)
  - [ ] 재생성 이력 데이터베이스 스키마
  - [ ] 로깅 미들웨어
  - [ ] 사용량 통계 수집
  - [ ] 모니터링 대시보드 연동

## Dev Notes

### 데이터베이스 스키마 확장

**재생성 이력 테이블:**

```sql
CREATE TABLE ai_regeneration_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  note_id UUID NOT NULL REFERENCES notes(id),
  type VARCHAR(20) NOT NULL, -- 'summary' | 'tags'
  previous_result JSONB,
  new_result JSONB,
  success BOOLEAN NOT NULL,
  error_message TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 인덱스
CREATE INDEX idx_ai_regen_logs_user_date ON ai_regeneration_logs(user_id, created_at);
CREATE INDEX idx_ai_regen_logs_note ON ai_regeneration_logs(note_id);
```

**사용량 추적 테이블:**

```sql
CREATE TABLE ai_usage_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  date DATE NOT NULL DEFAULT CURRENT_DATE,
  summary_regenerations INTEGER DEFAULT 0,
  tags_regenerations INTEGER DEFAULT 0,
  last_regeneration_at TIMESTAMP WITH TIME ZONE,
  UNIQUE(user_id, date)
);
```

### API 엔드포인트 구현

**요약 재생성 API:**

```typescript
// app/api/notes/[id]/regenerate-summary/route.ts
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // 1. 사용자 인증 및 권한 확인
    // 2. 쿨다운 및 일일 제한 확인
    // 3. 기존 요약 백업
    // 4. 새 요약 생성
    // 5. 성공 시 업데이트, 실패 시 롤백
    // 6. 로그 기록
    
    return NextResponse.json({
      success: true,
      summary: newSummary,
      previousSummary: previousSummary
    })
  } catch (error) {
    // 에러 로깅 및 응답
  }
}
```

**태그 재생성 API:**

```typescript
// app/api/notes/[id]/regenerate-tags/route.ts
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  // 요약 재생성과 유사한 로직
}
```

### 재생성 컴포넌트

**RegenerateButton 컴포넌트:**

```typescript
// components/ai/regenerate-button.tsx
interface RegenerateButtonProps {
  type: 'summary' | 'tags'
  noteId: string
  currentResult: string | string[]
  onRegenerateSuccess: (newResult: any) => void
  onRegenerateError: (error: string) => void
  disabled?: boolean
}

export function RegenerateButton({
  type,
  noteId,
  currentResult,
  onRegenerateSuccess,
  onRegenerateError,
  disabled = false
}: RegenerateButtonProps) {
  const [isRegenerating, setIsRegenerating] = useState(false)
  const [cooldownRemaining, setCooldownRemaining] = useState(0)
  const [showConfirmDialog, setShowConfirmDialog] = useState(false)

  // 쿨다운 타이머 로직
  // 재생성 API 호출 로직
  // 확인 다이얼로그 로직
}
```

**확인 다이얼로그:**

```typescript
// components/ai/regenerate-confirm-dialog.tsx
interface RegenerateConfirmDialogProps {
  isOpen: boolean
  type: 'summary' | 'tags'
  currentResult: string | string[]
  onConfirm: () => void
  onCancel: () => void
}

export function RegenerateConfirmDialog({
  isOpen,
  type,
  currentResult,
  onConfirm,
  onCancel
}: RegenerateConfirmDialogProps) {
  return (
    <AlertDialog open={isOpen} onOpenChange={onCancel}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>
            {type === 'summary' ? '요약' : '태그'} 재생성
          </AlertDialogTitle>
          <AlertDialogDescription>
            현재 {type === 'summary' ? '요약' : '태그'}를 새로 생성합니다.
            기존 결과는 덮어쓰여집니다.
          </AlertDialogDescription>
        </AlertDialogHeader>
        
        <div className="my-4 p-3 bg-gray-50 rounded-md">
          <p className="text-sm font-medium text-gray-700 mb-2">
            현재 {type === 'summary' ? '요약' : '태그'}:
          </p>
          {type === 'summary' ? (
            <p className="text-sm text-gray-600">{currentResult}</p>
          ) : (
            <div className="flex flex-wrap gap-1">
              {(currentResult as string[]).map((tag, index) => (
                <span
                  key={index}
                  className="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full"
                >
                  {tag}
                </span>
              ))}
            </div>
          )}
        </div>

        <AlertDialogFooter>
          <AlertDialogCancel onClick={onCancel}>
            취소
          </AlertDialogCancel>
          <AlertDialogAction onClick={onConfirm}>
            재생성
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  )
}
```

### 제한 및 보안 로직

**쿨다운 관리:**

```typescript
// lib/ai/cooldown-manager.ts
export class CooldownManager {
  private static instance: CooldownManager
  private cooldowns = new Map<string, number>()

  static getInstance(): CooldownManager {
    if (!CooldownManager.instance) {
      CooldownManager.instance = new CooldownManager()
    }
    return CooldownManager.instance
  }

  setCooldown(userId: string, type: 'summary' | 'tags'): void {
    const key = `${userId}-${type}`
    const expiresAt = Date.now() + (30 * 1000) // 30초
    this.cooldowns.set(key, expiresAt)
  }

  getRemainingCooldown(userId: string, type: 'summary' | 'tags'): number {
    const key = `${userId}-${type}`
    const expiresAt = this.cooldowns.get(key)
    
    if (!expiresAt) return 0
    
    const remaining = Math.max(0, expiresAt - Date.now())
    if (remaining === 0) {
      this.cooldowns.delete(key)
    }
    
    return Math.ceil(remaining / 1000) // 초 단위
  }
}
```

**일일 제한 체크:**

```typescript
// lib/ai/usage-limiter.ts
export async function checkDailyLimit(
  userId: string,
  type: 'summary' | 'tags'
): Promise<{ allowed: boolean; remaining: number }> {
  const today = new Date().toISOString().split('T')[0]
  
  const usage = await db
    .select()
    .from(aiUsageLimits)
    .where(and(
      eq(aiUsageLimits.userId, userId),
      eq(aiUsageLimits.date, today)
    ))
    .limit(1)

  const currentCount = usage[0]?.[`${type}_regenerations`] || 0
  const limit = 10 // 일일 제한
  
  return {
    allowed: currentCount < limit,
    remaining: Math.max(0, limit - currentCount)
  }
}

export async function incrementUsage(
  userId: string,
  type: 'summary' | 'tags'
): Promise<void> {
  const today = new Date().toISOString().split('T')[0]
  
  await db
    .insert(aiUsageLimits)
    .values({
      userId,
      date: today,
      [`${type}_regenerations`]: 1,
      lastRegenerationAt: new Date()
    })
    .onConflictDoUpdate({
      target: [aiUsageLimits.userId, aiUsageLimits.date],
      set: {
        [`${type}_regenerations`]: sql`${aiUsageLimits[`${type}_regenerations`]} + 1`,
        lastRegenerationAt: new Date()
      }
    })
}
```

### 에러 처리 및 롤백

**트랜잭션 처리:**

```typescript
// lib/ai/regeneration-service.ts
export async function regenerateWithRollback(
  noteId: string,
  type: 'summary' | 'tags',
  generateFn: () => Promise<any>
): Promise<{ success: boolean; result?: any; error?: string }> {
  return await db.transaction(async (tx) => {
    try {
      // 1. 기존 데이터 백업
      const backup = await tx
        .select()
        .from(notes)
        .where(eq(notes.id, noteId))
        .limit(1)

      if (!backup[0]) {
        throw new Error('노트를 찾을 수 없습니다.')
      }

      // 2. 새 결과 생성
      const newResult = await generateFn()

      // 3. 데이터베이스 업데이트
      await tx
        .update(notes)
        .set({
          [type]: newResult,
          [`${type}GeneratedAt`]: new Date(),
          [`${type}Status`]: 'completed',
          updatedAt: new Date()
        })
        .where(eq(notes.id, noteId))

      return { success: true, result: newResult }
    } catch (error) {
      // 트랜잭션 자동 롤백
      throw error
    }
  })
}
```

### UI 통합 지점

**SummaryGenerator 컴포넌트 확장:**

```typescript
// components/notes/summary-generator.tsx (기존 컴포넌트 확장)
export function SummaryGenerator({ 
  noteId, 
  content, 
  existingSummary,
  onSummaryGenerated 
}: SummaryGeneratorProps) {
  // 기존 로직...
  
  // 재생성 버튼 추가
  {existingSummary && (
    <RegenerateButton
      type="summary"
      noteId={noteId}
      currentResult={existingSummary}
      onRegenerateSuccess={(newSummary) => {
        onSummaryGenerated(newSummary)
      }}
      onRegenerateError={(error) => {
        setError(error)
      }}
    />
  )}
}
```

### 모니터링 및 분석

**사용량 통계:**

```typescript
// lib/ai/analytics.ts
export interface RegenerationStats {
  totalRegenerations: number
  summaryRegenerations: number
  tagsRegenerations: number
  successRate: number
  averageRegenerationsPerUser: number
  popularRegenerationReasons: string[]
}

export async function getRegenerationStats(
  startDate: Date,
  endDate: Date
): Promise<RegenerationStats> {
  // 재생성 통계 조회 로직
}
```

### 테스트 전략

**단위 테스트:**

```typescript
describe('RegenerateButton', () => {
  test('쿨다운 중에는 버튼이 비활성화됨', () => {
    // 쿨다운 테스트
  })
  
  test('일일 제한 초과 시 에러 메시지 표시', () => {
    // 제한 테스트
  })
  
  test('재생성 성공 시 새 결과로 업데이트', async () => {
    // 성공 케이스 테스트
  })
})
```

**통합 테스트:**

```typescript
describe('Regeneration Flow', () => {
  test('요약 재생성 전체 플로우', async () => {
    // 확인 → 재생성 → 업데이트 플로우 테스트
  })
  
  test('재생성 실패 시 롤백', async () => {
    // 실패 시 데이터 무결성 테스트
  })
})
```

## Change Log

| Date       | Version | Description | Author                    |
| ---------- | ------- | ----------- | ------------------------- |
| 2025-09-17 | 1.0     | 스토리 생성 | Scrum Master Bob Claude 4 Sonnet |

## Dev Agent Record

이 섹션은 개발 에이전트가 구현 중에 채워집니다.

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results

QA 에이전트가 완료된 스토리 구현을 검토한 결과입니다.
